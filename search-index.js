var searchIndex = JSON.parse('{\
"memchr":{"doc":"This library provides heavily optimized routines for …","t":[3,3,3,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,5,5,5,5,5,5,0,5,5,5,5,5,5,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,13,3,3,3,3,3,13,4,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,5,11,5,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,5,11,5,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11],"n":["Memchr","Memchr2","Memchr3","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","from","from","from","into","into","into","into_iter","into_iter","into_iter","memchr","memchr2","memchr2_iter","memchr3","memchr3_iter","memchr_iter","memmem","memrchr","memrchr2","memrchr2_iter","memrchr3","memrchr3_iter","memrchr_iter","new","new","new","next","next","next","next_back","next_back","next_back","size_hint","size_hint","size_hint","try_from","try_from","try_from","try_into","try_into","try_into","type_id","type_id","type_id","Auto","FindIter","FindRevIter","Finder","FinderBuilder","FinderRev","None","Prefilter","as_ref","as_ref","borrow","borrow","borrow","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","build_forward","build_reverse","clone","clone","clone","clone","clone_into","clone_into","clone_into","clone_into","default","default","find","find","find_iter","find_iter","fmt","fmt","fmt","fmt","fmt","fmt","from","from","from","from","from","from","into","into","into","into","into","into","into_iter","into_iter","into_owned","into_owned","needle","needle","new","new","new","next","next","prefilter","rfind","rfind","rfind_iter","rfind_iter","to_owned","to_owned","to_owned","to_owned","try_from","try_from","try_from","try_from","try_from","try_from","try_into","try_into","try_into","try_into","try_into","try_into","type_id","type_id","type_id","type_id","type_id","type_id"],"q":["memchr","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","memchr::memmem","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""],"d":["An iterator for <code>memchr</code>.","An iterator for <code>memchr2</code>.","An iterator for <code>memchr3</code>.","","","","","","","","","","","","","","","","Search for the first occurrence of a byte in a slice.","Like <code>memchr</code>, but searches for either of two bytes instead …","An iterator over all occurrences of the needles in a …","Like <code>memchr</code>, but searches for any of three bytes instead …","An iterator over all occurrences of the needles in a …","An iterator over all occurrences of the needle in a …","This module provides forward and reverse substring search …","Search for the last occurrence of a byte in a slice.","Like <code>memrchr</code>, but searches for either of two bytes instead …","An iterator over all occurrences of the needles in a …","Like <code>memrchr</code>, but searches for any of three bytes instead …","An iterator over all occurrences of the needles in a …","An iterator over all occurrences of the needle in a …","Creates a new iterator that yields all positions of needle …","Creates a new iterator that yields all positions of needle …","Create a new <code>Memchr3</code> that’s initialized to zero with a …","","","","","","","","","","","","","","","","","","","Automatically detect whether a heuristic prefilter should …","An iterator over non-overlapping substring matches.","An iterator over non-overlapping substring matches in …","A single substring searcher fixed to a particular needle.","A builder for constructing non-default forward or reverse …","A single substring reverse searcher fixed to a particular …","Never used a prefilter in substring search.","Prefilter controls whether heuristics are used to …","Convert this finder into its borrowed variant.","Convert this finder into its borrowed variant.","","","","","","","","","","","","","Build a forward finder using the given needle from the …","Build a reverse finder using the given needle from the …","","","","","","","","","","","Returns the index of the first occurrence of the given …","Returns the index of the first occurrence of this needle …","Returns an iterator over all occurrences of a substring in …","Returns an iterator over all occurrences of a substring in …","","","","","","","","","","","","","","","","","","","","","Convert this finder into its owned variant, such that it …","Convert this finder into its owned variant, such that it …","Returns the needle that this finder searches for.","Returns the needle that this finder searches for.","Create a new finder for the given needle.","Create a new reverse finder for the given needle.","Create a new finder builder with default settings.","","","Configure the prefilter setting for the finder.","Returns the index of the last occurrence of the given …","Returns the index of the last occurrence of this needle in …","Returns a reverse iterator over all occurrences of a …","Returns a reverse iterator over all occurrences of a …","","","","","","","","","","","","","","","","","","","","","",""],"i":[0,0,0,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,4,0,0,0,0,0,4,0,5,6,4,7,8,5,6,9,4,7,8,5,6,9,9,9,4,5,6,9,4,5,6,9,4,9,0,5,0,5,4,7,8,5,6,9,4,7,8,5,6,9,4,7,8,5,6,9,7,8,5,6,5,6,5,6,9,7,8,9,0,6,0,6,4,5,6,9,4,7,8,5,6,9,4,7,8,5,6,9,4,7,8,5,6,9],"f":[null,null,null,[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[["u8",15]],[["usize",15],["option",4,["usize"]]]],[[["u8",15]],[["usize",15],["option",4,["usize"]]]],[[["u8",15]],["memchr2",3]],[[["u8",15]],[["usize",15],["option",4,["usize"]]]],[[["u8",15]],["memchr3",3]],[[["u8",15]],["memchr",3]],null,[[["u8",15]],[["usize",15],["option",4,["usize"]]]],[[["u8",15]],[["usize",15],["option",4,["usize"]]]],[[["u8",15]],[["rev",3,["memchr2"]],["memchr2",3]]],[[["u8",15]],[["usize",15],["option",4,["usize"]]]],[[["u8",15]],[["rev",3,["memchr3"]],["memchr3",3]]],[[["u8",15]],[["rev",3,["memchr"]],["memchr",3]]],[[["u8",15]],["memchr",3]],[[["u8",15]],["memchr2",3]],[[["u8",15]],["memchr3",3]],[[],[["usize",15],["option",4,["usize"]]]],[[],[["usize",15],["option",4,["usize"]]]],[[],[["usize",15],["option",4,["usize"]]]],[[],["option",4]],[[],["option",4]],[[],["option",4]],[[]],[[]],[[]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],null,null,null,null,null,null,null,null,[[],["finder",3]],[[],["finderrev",3]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[],["finder",3]],[[],["finderrev",3]],[[],["prefilter",4]],[[],["finder",3]],[[],["finderrev",3]],[[],["finderbuilder",3]],[[]],[[]],[[]],[[]],[[],["prefilter",4]],[[],["finderbuilder",3]],[[],[["usize",15],["option",4,["usize"]]]],[[],[["usize",15],["option",4,["usize"]]]],[[],["finditer",3]],[[],["finditer",3]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[],["finder",3]],[[],["finderrev",3]],[[]],[[]],[[],["finder",3]],[[],["finderrev",3]],[[],["finderbuilder",3]],[[],[["usize",15],["option",4,["usize"]]]],[[],[["usize",15],["option",4,["usize"]]]],[[["prefilter",4]],["finderbuilder",3]],[[],[["usize",15],["option",4,["usize"]]]],[[["asref",8]],[["usize",15],["option",4,["usize"]]]],[[],["findreviter",3]],[[],["findreviter",3]],[[]],[[]],[[]],[[]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]]],"p":[[3,"Memchr"],[3,"Memchr2"],[3,"Memchr3"],[4,"Prefilter"],[3,"Finder"],[3,"FinderRev"],[3,"FindIter"],[3,"FindRevIter"],[3,"FinderBuilder"]]},\
"minimal_lexical":{"doc":"Fast, minimal float-parsing algorithm.","t":[18,18,18,18,18,18,18,18,8,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,11,11,10,10,11,11,11,11,11,11,5,10,10],"n":["CARRY_MASK","CARRY_MASK","DENORMAL_EXPONENT","DENORMAL_EXPONENT","EXPONENT_BIAS","EXPONENT_BIAS","EXPONENT_MASK","EXPONENT_MASK","Float","HIDDEN_BIT_MASK","HIDDEN_BIT_MASK","INFINITE_POWER","INFINITE_POWER","INVALID_FP","INVALID_FP","LARGEST_POWER_OF_TEN","LARGEST_POWER_OF_TEN","MANTISSA_MASK","MANTISSA_MASK","MANTISSA_SIZE","MANTISSA_SIZE","MAX_DIGITS","MAX_DIGITS","MAX_EXPONENT","MAX_EXPONENT","MAX_EXPONENT_DISGUISED_FAST_PATH","MAX_EXPONENT_DISGUISED_FAST_PATH","MAX_EXPONENT_FAST_PATH","MAX_EXPONENT_FAST_PATH","MAX_EXPONENT_ROUND_TO_EVEN","MAX_EXPONENT_ROUND_TO_EVEN","MAX_MANTISSA_FAST_PATH","MAX_MANTISSA_FAST_PATH","MINIMUM_EXPONENT","MINIMUM_EXPONENT","MIN_EXPONENT_FAST_PATH","MIN_EXPONENT_FAST_PATH","MIN_EXPONENT_ROUND_TO_EVEN","MIN_EXPONENT_ROUND_TO_EVEN","SIGN_MASK","SIGN_MASK","SMALLEST_POWER_OF_TEN","SMALLEST_POWER_OF_TEN","exponent","exponent","from_bits","from_u64","int_pow_fast_path","int_pow_fast_path","is_denormal","is_denormal","mantissa","mantissa","parse_float","pow_fast_path","to_bits"],"q":["minimal_lexical","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""],"d":["Mask to determine if a full-carry occurred (1 in bit above …","Mask to determine if a full-carry occurred (1 in bit above …","Exponent portion of a denormal float.","Exponent portion of a denormal float.","Bias of the exponet","Bias of the exponet","Bitmask for the exponent, including the hidden bit.","Bitmask for the exponent, including the hidden bit.","Generic floating-point type, to be used in generic code …","Bitmask for the hidden bit in exponent, which is an …","Bitmask for the hidden bit in exponent, which is an …","","","Bias for marking an invalid extended float.","Bias for marking an invalid extended float.","Largest decimal exponent for a non-infinite value.","Largest decimal exponent for a non-infinite value.","Bitmask for the mantissa (fraction), excluding the hidden …","Bitmask for the mantissa (fraction), excluding the hidden …","Size of the significand (mantissa) without hidden bit.","Size of the significand (mantissa) without hidden bit.","Maximum number of digits that can contribute in the …","Maximum number of digits that can contribute in the …","Maximum exponent value in float.","Maximum exponent value in float.","Maximum exponent that can be represented for a …","Maximum exponent that can be represented for a …","Maximum exponent that for a fast path case, or …","Maximum exponent that for a fast path case, or …","","","","","Minimum normal exponent value …","Minimum normal exponent value …","Minimum exponent that for a fast path case, or …","Minimum exponent that for a fast path case, or …","","","Bitmask for the sign bit.","Bitmask for the sign bit.","Smallest decimal exponent for a non-zero value.","Smallest decimal exponent for a non-zero value.","Get exponent component from the float.","Get exponent component from the float.","","Convert 64-bit integer to float.","Get a small, integral power-of-radix for fast-path …","Get a small, integral power-of-radix for fast-path …","Returns true if the float is a denormal.","Returns true if the float is a denormal.","Get mantissa (significand) component from float.","Get mantissa (significand) component from float.","Parse float from extracted float components.","Get a small power-of-radix for fast-path multiplication.",""],"i":[1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1],"f":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,[[],["i32",15]],[[],["i32",15]],[[["u64",15]]],[[["u64",15]]],[[["usize",15],["u32",15]],["u64",15]],[[["usize",15],["u32",15]],["u64",15]],[[],["bool",15]],[[],["bool",15]],[[],["u64",15]],[[],["u64",15]],[[["i32",15]]],[[["usize",15]]],[[],["u64",15]]],"p":[[8,"Float"]]},\
"nom":{"doc":"nom, eating data byte by byte","t":[3,3,8,8,8,4,4,13,13,8,8,16,13,8,8,8,3,8,6,13,13,8,8,8,8,3,16,16,16,16,16,3,4,8,13,3,8,8,13,8,8,13,8,11,11,11,11,10,10,0,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,0,0,0,11,11,11,11,0,10,10,10,11,11,11,11,0,14,14,10,10,10,10,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,10,11,11,11,11,11,11,11,11,11,11,11,10,10,10,10,11,11,10,10,10,10,0,11,11,11,11,11,11,0,11,11,11,10,0,10,11,11,10,11,11,11,11,11,11,10,10,0,10,10,11,10,10,10,10,10,10,10,10,11,11,11,11,11,11,11,10,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,12,12,12,5,5,0,0,5,5,5,5,8,8,5,10,5,10,0,0,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,0,5,5,5,5,5,5,5,0,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,3,5,11,11,5,5,5,5,5,5,11,5,11,5,11,5,5,5,5,5,5,5,5,5,5,5,5,11,11,11,5,5,13,13,13,13,13,13,13,8,13,13,13,13,3,4,13,13,13,13,13,8,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,8,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,3,4,13,11,11,10,11,11,5,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,5,11,11,11,11,5,5,11,11,11,11,11,5,12,11,11,11,11,11,11,11,11,11,11,11,11,10,11,11,10,11,11,11,12,11,11,11,11,5,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,12,12,0,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,13,4,13,13,11,11,11,11,0,11,11,11,11,0,11,11,11,11,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,8,5,5,10,5,5,5,5],"n":["And","AndThen","AsBytes","AsChar","Compare","CompareResult","Err","Error","Error","ErrorConvert","ExtendInto","Extender","Failure","FindSubstring","FindToken","Finish","FlatMap","HexDisplay","IResult","Incomplete","Incomplete","InputIter","InputLength","InputTake","InputTakeAtPosition","Into","Item","Item","Item","Iter","IterElem","Map","Needed","Offset","Ok","Or","ParseTo","Parser","Size","Slice","ToUsize","Unknown","UnspecializedInput","and","and","and_then","and_then","as_bytes","as_char","bits","borrow","borrow","borrow","borrow","borrow","borrow","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","branch","bytes","character","clone","clone","clone_into","clone_into","combinator","compare","compare_no_case","convert","convert","eq","eq","eq","error","error_node_position","error_position","extend_into","find_substring","find_token","finish","finish","flat_map","flat_map","fmt","fmt","fmt","fmt","from","from","from","from","from","from","from","from","from","input_len","into","into","into","into","into","into","into","into","into","into","into","is_alpha","is_alphanum","is_dec_digit","is_hex_digit","is_incomplete","is_known","is_oct_digit","iter_elements","iter_indices","len","lib","map","map","map","map","map_input","map_input","multi","ne","ne","new","new_builder","number","offset","or","or","parse","parse","parse","parse","parse","parse","parse","parse_to","position","sequence","slice","slice_index","source","split_at_position","split_at_position1","split_at_position1_complete","split_at_position_complete","take","take_split","to_hex","to_hex_from","to_owned","to_owned","to_owned","to_owned","to_owned","to_owned","to_string","to_usize","try_from","try_from","try_from","try_from","try_from","try_from","try_from","try_from","try_from","try_into","try_into","try_into","try_into","try_into","try_into","try_into","try_into","try_into","type_id","type_id","type_id","type_id","type_id","type_id","type_id","type_id","type_id","0","0","0","0","bits","bytes","complete","streaming","tag","take","tag","take","Alt","Permutation","alt","choice","permutation","permutation","complete","streaming","escaped","escaped_transform","is_a","is_not","tag","tag_no_case","take","take_till","take_till1","take_until","take_until1","take_while","take_while1","take_while_m_n","escaped","escaped_transform","is_a","is_not","tag","tag_no_case","take","take_till","take_till1","take_until","take_until1","take_while","take_while1","take_while_m_n","complete","is_alphabetic","is_alphanumeric","is_digit","is_hex_digit","is_newline","is_oct_digit","is_space","streaming","alpha0","alpha1","alphanumeric0","alphanumeric1","anychar","char","crlf","digit0","digit1","hex_digit0","hex_digit1","i128","i16","i32","i64","i8","line_ending","multispace0","multispace1","newline","none_of","not_line_ending","oct_digit0","oct_digit1","one_of","satisfy","space0","space1","tab","u128","u16","u32","u64","u8","alpha0","alpha1","alphanumeric0","alphanumeric1","anychar","char","crlf","digit0","digit1","hex_digit0","hex_digit1","i128","i16","i32","i64","i8","line_ending","multispace0","multispace1","newline","none_of","not_line_ending","oct_digit0","oct_digit1","one_of","satisfy","space0","space1","tab","u128","u16","u32","u64","u8","ParserIterator","all_consuming","borrow","borrow_mut","complete","cond","consumed","cut","eof","fail","finish","flat_map","from","into","into","iterator","map","map_opt","map_parser","map_res","not","opt","peek","recognize","rest","rest_len","success","try_from","try_into","type_id","value","verify","Alpha","AlphaNumeric","Alt","Char","Char","Complete","Context","ContextError","Count","CrLf","Digit","Eof","Error","ErrorKind","Escaped","EscapedTransform","Fail","Fix","Float","FromExternalError","HexDigit","IsA","IsNot","LengthValue","LengthValueFn","Many0","Many0Count","Many1","Many1Count","ManyMN","ManyTill","MapOpt","MapRes","MultiSpace","Nom","NonEmpty","NoneOf","Not","OctDigit","OneOf","ParseError","Permutation","RegexpCapture","RegexpCaptures","RegexpFind","RegexpMatch","RegexpMatches","Satisfy","SeparatedList","SeparatedNonEmptyList","Space","Switch","Tag","TagBits","TagClosure","TakeTill1","TakeUntil","TakeWhile1","TakeWhileMN","TooLarge","VerboseError","VerboseErrorKind","Verify","add_context","add_context","append","append","append","append_error","borrow","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","borrow_mut","clone","clone","clone","clone_into","clone_into","clone_into","code","context","convert","convert","convert","convert","convert_error","dbg_dmp","description","eq","eq","eq","eq","error_to_u32","errors","fmt","fmt","fmt","fmt","fmt","fmt","from","from","from","from","from_char","from_char","from_error_kind","from_error_kind","from_error_kind","from_external_error","from_external_error","from_external_error","hash","input","into","into","into","into","make_error","ne","ne","ne","new","or","to_owned","to_owned","to_owned","to_string","to_string","try_from","try_from","try_from","try_from","try_into","try_into","try_into","try_into","type_id","type_id","type_id","type_id","0","0","0","std","count","fill","fold_many0","fold_many1","fold_many_m_n","length_count","length_data","length_value","many0","many0_count","many1","many1_count","many_m_n","many_till","separated_list0","separated_list1","Big","Endianness","Little","Native","borrow","borrow_mut","clone","clone_into","complete","eq","fmt","from","into","streaming","to_owned","try_from","try_into","type_id","be_f32","be_f64","be_i128","be_i16","be_i24","be_i32","be_i64","be_i8","be_u128","be_u16","be_u24","be_u32","be_u64","be_u8","double","f32","f64","float","hex_u32","i128","i16","i24","i32","i64","i8","le_f32","le_f64","le_i128","le_i16","le_i24","le_i32","le_i64","le_i8","le_u128","le_u16","le_u24","le_u32","le_u64","le_u8","recognize_float","recognize_float_parts","u128","u16","u24","u32","u64","u8","be_f32","be_f64","be_i128","be_i16","be_i24","be_i32","be_i64","be_i8","be_u128","be_u16","be_u24","be_u32","be_u64","be_u8","double","f32","f64","float","hex_u32","i128","i16","i24","i32","i64","i8","le_f32","le_f64","le_i128","le_i16","le_i24","le_i32","le_i64","le_i8","le_u128","le_u16","le_u24","le_u32","le_u64","le_u8","recognize_float","recognize_float_parts","u128","u16","u24","u32","u64","u8","Tuple","delimited","pair","parse","preceded","separated_pair","terminated","tuple"],"q":["nom","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","nom::Err","","","nom::Needed","nom::bits","","","","nom::bits::complete","","nom::bits::streaming","","nom::branch","","","","","","nom::bytes","","nom::bytes::complete","","","","","","","","","","","","","","nom::bytes::streaming","","","","","","","","","","","","","","nom::character","","","","","","","","","nom::character::complete","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","nom::character::streaming","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","nom::combinator","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","nom::error","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","nom::error::VerboseErrorKind","","","nom::lib","nom::multi","","","","","","","","","","","","","","","","nom::number","","","","","","","","","","","","","","","","","","nom::number::complete","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","nom::number::streaming","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","nom::sequence","","","","","","",""],"d":["Implementation of <code>Parser::and</code>","Implementation of <code>Parser::and_then</code>","Helper trait for types that can be viewed as a byte slice","Transforms common types to a char for basic token parsing","Abstracts comparison operations","Indicates whether a comparison was successful, an error, or","The <code>Err</code> enum indicates the parser was not successful","The parser had an error (recoverable)","Comparison failed","Equivalent From implementation to avoid orphan rules in …","Abstracts something which can extend an <code>Extend</code>. Used to …","The type that will be produced","The parser had an unrecoverable error: we got to the right …","Look for a substring in self","Look for a token in self","Helper trait to convert a parser’s result to a more …","Implementation of <code>Parser::flat_map</code>","Helper trait to show a byte slice as a hex dump","Holds the result of parsing functions","There was not enough data","We need more data to be sure","Abstracts common iteration operations on the input type","Abstract method to calculate the input length","Abstracts slicing operations","Methods to take as much input as possible until the …","Implementation of <code>Parser::into</code>","The current input type is a sequence of that <code>Item</code> type.","The current input type is a sequence of that <code>Item</code> type.","The current input type is a sequence of that <code>Item</code> type.","An iterator over the input type, producing the item and …","An iterator over the input type, producing the item","Implementation of <code>Parser::map</code>","Contains information on needed data if a parser returned …","Useful functions to calculate the offset between slices …","Comparison was successful","Implementation of <code>Parser::or</code>","Used to integrate <code>str</code>’s <code>parse()</code> method","All nom parsers implement this trait","Contains the required data size in bytes","Slicing operations using ranges.","Helper trait to convert numbers to usize.","Needs more data, but we do not know how much","Dummy trait used for default implementations (currently …","Applies a second parser after the first one, return their …","Applies a second parser after the first one, return their …","Applies a second parser over the output of the first one","Applies a second parser over the output of the first one","Casts the input type to a byte slice","makes a char from self","Bit level parsers","","","","","","","","","","","","","","","","","","","Choice combinators","Parsers recognizing bytes streams","Character specific parsers and combinators","","","","","General purpose combinators","Compares self to another value for equality","Compares self to another value for equality independently …","Transform to another error type","Automatically converts between errors if the underlying …","","","","Error management","Creates a parse error from a <code>nom::ErrorKind</code>, the position …","Creates a parse error from a <code>nom::ErrorKind</code> and the …","Accumulate the input into an accumulator","Returns the byte position of the substring if it is found","Returns true if self contains the token","converts the parser’s result to a type that is more …","","Creates a second parser from the output of the first one, …","Creates a second parser from the output of the first one, …","","","","","","","","","","","","","","Calculates the input length, as indicated by its name, and …","automatically converts the parser’s output and error …","automatically converts the parser’s output and error …","","","","","","","","","","Tests that self is an alphabetic character","Tests that self is an alphabetic character or a decimal …","Tests that self is a decimal digit","Tests that self is an hex digit","Tests if the result is Incomplete","Indicates if we know how many bytes we need","Tests that self is an octal digit","Returns an iterator over the elements","Returns an iterator over the elements and their byte …","Gets the len in bytes for self","Lib module to re-export everything needed from <code>std</code> or <code>core</code>/…","Maps a function over the result of a parser","Maps a function over the result of a parser","Maps a <code>Needed</code> to <code>Needed</code> by applying a function to a …","Applies the given function to the inner error","Maps <code>Err&lt;error::Error&lt;T&gt;&gt;</code> to <code>Err&lt;error::Error&lt;U&gt;&gt;</code> with the …","Maps <code>Err&lt;(T, ErrorKind)&gt;</code> to <code>Err&lt;(U, ErrorKind)&gt;</code> with the …","Combinators applying their child parser multiple times","","","Creates <code>Needed</code> instance, returns <code>Needed::Unknown</code> if the …","Create a new <code>Extend</code> of the correct type","Parsers recognizing numbers","Offset between the first byte of self and the first byte …","Applies a second parser over the input if the first one …","Applies a second parser over the input if the first one …","A parser takes in input type, and returns a <code>Result</code> …","","","","","","","Succeeds if <code>parse()</code> succeeded. The byte slice …","Finds the byte position of the element","Combinators applying parsers in sequence","Slices self according to the range argument","Get the byte offset from the element’s position in the …","","Looks for the first element of the input type for which …","Looks for the first element of the input type for which …","Looks for the first element of the input type for which …","Looks for the first element of the input type for which …","Returns a slice of <code>count</code> bytes. panics if count &gt; length","Split the stream at the <code>count</code> byte offset. panics if count …","Converts the value of <code>self</code> to a hex dump, returning the …","Converts the value of <code>self</code> to a hex dump beginning at <code>from</code> …","","Obtaining ownership","","Obtaining ownership","Obtaining ownership","Obtaining ownership","","converts self to usize","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","Converts a byte-level input to a bit-level input, for …","Counterpart to <code>bits</code>, <code>bytes</code> transforms its bit stream input …","Bit level parsers","Bit level parsers","Generates a parser taking <code>count</code> bits and comparing them to …","Generates a parser taking <code>count</code> bits","Generates a parser taking <code>count</code> bits and comparing them to …","Generates a parser taking <code>count</code> bits","Helper trait for the alt() combinator.","Helper trait for the permutation() combinator.","Tests a list of parsers one by one until one succeeds.","Tests each parser in the tuple and returns the result of …","Applies a list of parsers in any order.","Tries to apply all parsers in the tuple in various orders …","Parsers recognizing bytes streams, complete input version","Parsers recognizing bytes streams, streaming version","Matches a byte string with escaped characters.","Matches a byte string with escaped characters.","Returns the longest slice of the matches the pattern.","Parse till certain characters are met.","Recognizes a pattern","Recognizes a case insensitive pattern.","Returns an input slice containing the first N input …","Returns the longest input slice (if any) till a predicate …","Returns the longest (at least 1) input slice till a …","Returns the input slice up to the first occurrence of the …","Returns the non empty input slice up to the first …","Returns the longest input slice (if any) that matches the …","Returns the longest (at least 1) input slice that matches …","Returns the longest (m &lt;= len &lt;= n) input slice  that …","Matches a byte string with escaped characters.","Matches a byte string with escaped characters.","Returns the longest slice of the matches the pattern.","Parse till certain characters are met.","Recognizes a pattern.","Recognizes a case insensitive pattern.","Returns an input slice containing the first N input …","Returns the longest input slice (if any) till a predicate …","Returns the longest (at least 1) input slice till a …","Returns the input slice up to the first occurrence of the …","Returns the non empty input slice up to the first …","Returns the longest input slice (if any) that matches the …","Returns the longest (at least 1) input slice that matches …","Returns the longest (m &lt;= len &lt;= n) input slice  that …","Character specific parsers and combinators, complete input …","Tests if byte is ASCII alphabetic: A-Z, a-z","Tests if byte is ASCII alphanumeric: A-Z, a-z, 0-9","Tests if byte is ASCII digit: 0-9","Tests if byte is ASCII hex digit: 0-9, A-F, a-f","Tests if byte is ASCII newline: \\\\n","Tests if byte is ASCII octal digit: 0-7","Tests if byte is ASCII space or tab","Character specific parsers and combinators, streaming …","Recognizes zero or more lowercase and uppercase ASCII …","Recognizes one or more lowercase and uppercase ASCII …","Recognizes zero or more ASCII numerical and alphabetic …","Recognizes one or more ASCII numerical and alphabetic …","Matches one byte as a character. Note that the input type …","Recognizes one character.","Recognizes the string “\\\\r\\\\n”.","Recognizes zero or more ASCII numerical characters: 0-9","Recognizes one or more ASCII numerical characters: 0-9","Recognizes zero or more ASCII hexadecimal numerical …","Recognizes one or more ASCII hexadecimal numerical …","will parse a number in text form to a number","will parse a number in text form to a number","will parse a number in text form to a number","will parse a number in text form to a number","will parse a number in text form to a number","Recognizes an end of line (both ‘\\\\n’ and ‘\\\\r\\\\n’).","Recognizes zero or more spaces, tabs, carriage returns and …","Recognizes one or more spaces, tabs, carriage returns and …","Matches a newline character ‘\\\\n’.","Recognizes a character that is not in the provided …","Recognizes a string of any char except ‘\\\\r\\\\n’ or ‘\\\\n…","Recognizes zero or more octal characters: 0-7","Recognizes one or more octal characters: 0-7","Recognizes one of the provided characters.","Recognizes one character and checks that it satisfies a …","Recognizes zero or more spaces and tabs.","Recognizes one or more spaces and tabs.","Matches a tab character ‘\\\\t’.","will parse a number in text form to a number","will parse a number in text form to a number","will parse a number in text form to a number","will parse a number in text form to a number","will parse a number in text form to a number","Recognizes zero or more lowercase and uppercase ASCII …","Recognizes one or more lowercase and uppercase ASCII …","Recognizes zero or more ASCII numerical and alphabetic …","Recognizes one or more ASCII numerical and alphabetic …","Matches one byte as a character. Note that the input type …","Recognizes one character.","Recognizes the string “\\\\r\\\\n”.","Recognizes zero or more ASCII numerical characters: 0-9","Recognizes one or more ASCII numerical characters: 0-9","Recognizes zero or more ASCII hexadecimal numerical …","Recognizes one or more ASCII hexadecimal numerical …","will parse a number in text form to a number","will parse a number in text form to a number","will parse a number in text form to a number","will parse a number in text form to a number","will parse a number in text form to a number","Recognizes an end of line (both ‘\\\\n’ and ‘\\\\r\\\\n’).","Recognizes zero or more spaces, tabs, carriage returns and …","Recognizes one or more spaces, tabs, carriage returns and …","Matches a newline character ‘\\\\n’.","Recognizes a character that is not in the provided …","Recognizes a string of any char except ‘\\\\r\\\\n’ or ‘\\\\n…","Recognizes zero or more octal characters: 0-7","Recognizes one or more octal characters: 0-7","Recognizes one of the provided characters.","Recognizes one character and checks that it satisfies a …","Recognizes zero or more spaces and tabs.","Recognizes one or more spaces and tabs.","Matches a tab character ‘\\\\t’.","will parse a number in text form to a number","will parse a number in text form to a number","will parse a number in text form to a number","will parse a number in text form to a number","will parse a number in text form to a number","Main structure associated to the iterator function.","Succeeds if all the input has been consumed by its child …","","","Transforms Incomplete into <code>Error</code>.","Calls the parser if the condition is met.","if the child parser was successful, return the consumed …","transforms an error to failure","returns its input if it is at the end of input data","A parser which always fails.","Returns the remaining input if parsing was successful, or …","Creates a new parser from the output of the first parser, …","","automatically converts the child parser’s result to …","","Creates an iterator from input data and a parser.","Maps a function on the result of a parser.","Applies a function returning an <code>Option</code> over the result of …","Applies a parser over the result of another one.","Applies a function returning a <code>Result</code> over the result of a …","Succeeds if the child parser returns an error.","Optional parser: Will return <code>None</code> if not successful.","Tries to apply its parser without consuming the input.","If the child parser was successful, return the consumed …","Return the remaining input.","Return the length of the remaining input.","a parser which always succeeds with given value without …","","","","Returns the provided value if the child parser succeeds.","Returns the result of the child parser if it satisfies a …","","","","Indicates which character was expected by the <code>char</code> function","","","Static string added by the <code>context</code> function","This trait is required by the <code>context</code> combinator to add a …","","","","","default error type, only contains the error’ location …","Indicates which parser returned an error","","","","","","This trait is required by the <code>map_res</code> combinator to …","","","","","","","","","","","","","","","Error kind given by various nom parsers","","","","","","This trait must be implemented by the error type of a nom …","","","","","","","","","","","","","","","","","","","","This error type accumulates errors and their position when …","Error context for <code>VerboseError</code>","","Creates a new error from an input position, a static …","","Combines an existing error with a new one created from the …","","","Combines an existing error with a new one created from the …","","","","","","","","","","","","","","","nom error code","Create a new error from an input position, a static string …","","","","","Transforms a <code>VerboseError</code> into a trace with input position …","Prints a message and the input if the parser fails.","Converts an ErrorKind to a text description","","","","","Converts an ErrorKind to a number","List of errors accumulated by <code>VerboseError</code>, containing the …","","","","","","","","","","","Creates an error from an input position and an expected …","","Creates an error from the input position and an ErrorKind","","","Creates a new error from an input position, an ErrorKind …","Create a new error from an input position and an external …","Create a new error from an input position and an external …","","position of the error in the input data","","","","","Creates an error from the input position and an ErrorKind","","","","creates a new basic error","Combines two existing errors. This function is used to …","","","","","","","","","","","","","","","","","","","","","internal std exports for no_std compatibility","Runs the embedded parser a specified number of times. …","Runs the embedded parser repeatedly, filling the given …","Applies a parser until it fails and accumulates the …","Applies a parser until it fails and accumulates the …","Applies a parser <code>n</code> times or until it fails and accumulates …","Gets a number from the first parser, then applies the …","Gets a number from the parser and returns a subslice of …","Gets a number from the first parser, takes a subslice of …","Repeats the embedded parser until it fails and returns the …","Repeats the embedded parser until it fails and returns the …","Runs the embedded parser until it fails and returns the …","Repeats the embedded parser until it fails and returns the …","Repeats the embedded parser <code>n</code> times or until it fails and …","Applies the parser <code>f</code> until the parser <code>g</code> produces a result. …","Alternates between two parsers to produce a list of …","Alternates between two parsers to produce a list of …","Big endian","Configurable endianness","Little endian","Will match the host’s endianness","","","","","Parsers recognizing numbers, complete input version","","","","","Parsers recognizing numbers, streaming version","","","","","Recognizes a big endian 4 bytes floating point number.","Recognizes a big endian 8 bytes floating point number.","Recognizes a big endian signed 16 bytes integer.","Recognizes a big endian signed 2 bytes integer.","Recognizes a big endian signed 3 bytes integer.","Recognizes a big endian signed 4 bytes integer.","Recognizes a big endian signed 8 bytes integer.","Recognizes a signed 1 byte integer.","Recognizes a big endian unsigned 16 bytes integer.","Recognizes a big endian unsigned 2 bytes integer.","Recognizes a big endian unsigned 3 byte integer.","Recognizes a big endian unsigned 4 bytes integer.","Recognizes a big endian unsigned 8 bytes integer.","Recognizes an unsigned 1 byte integer.","Recognizes floating point number in text format and …","Recognizes a 4 byte floating point number","Recognizes an 8 byte floating point number","Recognizes floating point number in text format and …","Recognizes a hex-encoded integer.","Recognizes a signed 16 byte integer","Recognizes a signed 2 byte integer","Recognizes a signed 3 byte integer","Recognizes a signed 4 byte integer","Recognizes a signed 8 byte integer","Recognizes a signed 1 byte integer","Recognizes a little endian 4 bytes floating point number.","Recognizes a little endian 8 bytes floating point number.","Recognizes a little endian signed 16 bytes integer.","Recognizes a little endian signed 2 bytes integer.","Recognizes a little endian signed 3 bytes integer.","Recognizes a little endian signed 4 bytes integer.","Recognizes a little endian signed 8 bytes integer.","Recognizes a signed 1 byte integer.","Recognizes a little endian unsigned 16 bytes integer.","Recognizes a little endian unsigned 2 bytes integer.","Recognizes a little endian unsigned 3 byte integer.","Recognizes a little endian unsigned 4 bytes integer.","Recognizes a little endian unsigned 8 bytes integer.","Recognizes an unsigned 1 byte integer.","Recognizes floating point number in a byte string and …","Recognizes a floating point number in text format and …","Recognizes an unsigned 16 byte integer","Recognizes an unsigned 2 bytes integer","Recognizes an unsigned 3 byte integer","Recognizes an unsigned 4 byte integer","Recognizes an unsigned 8 byte integer","Recognizes an unsigned 1 byte integer","Recognizes a big endian 4 bytes floating point number.","Recognizes a big endian 8 bytes floating point number.","Recognizes a big endian signed 16 bytes integer.","Recognizes a big endian signed 2 bytes integer.","Recognizes a big endian signed 3 bytes integer.","Recognizes a big endian signed 4 bytes integer.","Recognizes a big endian signed 8 bytes integer.","Recognizes a signed 1 byte integer.","Recognizes a big endian unsigned 16 bytes integer.","Recognizes a big endian unsigned 2 bytes integer.","Recognizes a big endian unsigned 3 byte integer.","Recognizes a big endian unsigned 4 bytes integer.","Recognizes a big endian unsigned 8 bytes integer.","Recognizes an unsigned 1 byte integer.","Recognizes floating point number in text format and …","Recognizes a 4 byte floating point number","Recognizes an 8 byte floating point number","Recognizes floating point number in text format and …","Recognizes a hex-encoded integer.","Recognizes a signed 16 byte integer","Recognizes a signed 2 byte integer","Recognizes a signed 3 byte integer","Recognizes a signed 4 byte integer","Recognizes a signed 8 byte integer","Recognizes a signed 1 byte integer","Recognizes a little endian 4 bytes floating point number.","Recognizes a little endian 8 bytes floating point number.","Recognizes a little endian signed 16 bytes integer.","Recognizes a little endian signed 2 bytes integer.","Recognizes a little endian signed 3 bytes integer.","Recognizes a little endian signed 4 bytes integer.","Recognizes a little endian signed 8 bytes integer.","Recognizes a signed 1 byte integer.","Recognizes a little endian unsigned 16 bytes integer.","Recognizes a little endian unsigned 2 bytes integer.","Recognizes a little endian unsigned 3 bytes integer.","Recognizes a little endian unsigned 4 bytes integer.","Recognizes a little endian unsigned 8 bytes integer.","Recognizes an unsigned 1 byte integer.","Recognizes a floating point number in text format and …","Recognizes a floating point number in text format and …","Recognizes an unsigned 16 byte integer","Recognizes an unsigned 2 bytes integer","Recognizes an unsigned 3 byte integer","Recognizes an unsigned 4 byte integer","Recognizes an unsigned 8 byte integer","Recognizes an unsigned 1 byte integer","Helper trait for the tuple combinator.","Matches an object from the first parser and discards it, …","Gets an object from the first parser, then gets another …","Parses the input and returns a tuple of results of each …","Matches an object from the first parser and discards it, …","Gets an object from the first parser, then matches an …","Gets an object from the first parser, then matches an …","Applies a tuple of parsers one by one and returns their …"],"i":[0,0,0,0,0,0,0,1,2,0,0,3,1,0,0,0,0,0,0,1,2,0,0,0,0,0,4,5,3,4,4,0,0,0,2,0,0,0,6,0,0,6,0,7,7,7,7,8,9,0,10,11,12,13,14,15,6,1,2,10,11,12,13,14,15,6,1,2,0,0,0,6,1,6,1,0,16,16,17,1,6,1,2,0,0,0,3,18,19,20,21,7,7,6,1,1,2,10,11,12,13,14,15,6,1,2,22,7,7,10,11,12,13,14,15,6,1,2,9,9,9,9,1,6,9,4,4,9,0,7,7,6,1,1,1,0,6,1,6,3,0,23,7,7,7,10,11,12,13,14,15,24,4,0,25,4,1,5,5,5,5,26,26,27,27,6,1,1,1,1,1,1,28,10,11,12,13,14,15,6,1,2,10,11,12,13,14,15,6,1,2,10,11,12,13,14,15,6,1,2,29,30,31,32,0,0,0,0,0,0,0,0,0,0,0,33,0,34,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,35,35,0,0,0,0,0,0,35,0,35,0,35,0,0,0,0,0,0,0,0,0,0,0,0,35,35,35,0,0,36,36,36,37,36,36,37,0,36,36,36,36,0,0,36,36,36,36,36,0,36,36,36,36,36,36,36,36,36,36,36,36,36,36,37,36,36,36,36,36,0,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,0,0,36,38,39,40,41,39,0,41,39,37,36,41,39,37,36,39,37,36,39,37,36,41,0,41,41,39,39,0,0,36,41,39,37,36,0,39,41,41,39,39,37,36,41,39,37,36,40,39,40,41,39,42,41,39,36,41,41,39,37,36,0,41,39,37,41,40,39,37,36,41,39,41,39,37,36,41,39,37,36,41,39,37,36,43,44,45,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,46,0,46,46,46,46,46,46,0,46,46,46,46,0,46,46,46,46,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,47,0,0,0,0],"f":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,[[],["and",3]],[[],["and",3]],[[],["andthen",3]],[[],["andthen",3]],[[]],[[],["char",15]],null,[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],null,null,null,[[],["needed",4]],[[],["err",4]],[[]],[[]],null,[[],["compareresult",4]],[[],["compareresult",4]],[[]],[[["err",4]]],[[["needed",4]],["bool",15]],[[["err",4]],["bool",15]],[[["compareresult",4]],["bool",15]],null,null,null,[[]],[[],[["usize",15],["option",4,["usize"]]]],[[],["bool",15]],[[],["result",4]],[[],["result",4]],[[],["flatmap",3]],[[],["flatmap",3]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[],["usize",15]],[[],[["into",3],["from",8],["from",8]]],[[],[["into",3],["from",8],["from",8]]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[],["bool",15]],[[],["bool",15]],[[],["bool",15]],[[],["bool",15]],[[],["bool",15]],[[],["bool",15]],[[],["bool",15]],[[]],[[]],[[],["usize",15]],null,[[],["map",3]],[[],["map",3]],[[["fn",8]],["needed",4]],[[],["err",4]],[[],[["err",4,["error"]],["error",3]]],[[],["err",4]],null,[[["needed",4]],["bool",15]],[[["err",4]],["bool",15]],[[["usize",15]]],[[]],null,[[],["usize",15]],[[],["or",3]],[[],["or",3]],[[],["iresult",6]],[[],["iresult",6]],[[],["iresult",6]],[[],["iresult",6]],[[],["iresult",6]],[[],["iresult",6]],[[],["iresult",6]],[[],["option",4]],[[],[["usize",15],["option",4,["usize"]]]],null,[[]],[[["usize",15]],[["usize",15],["result",4,["usize","needed"]],["needed",4]]],[[],[["error",8],["option",4,["error"]]]],[[],[["iresult",6],["parseerror",8]]],[[["errorkind",4]],[["iresult",6],["parseerror",8]]],[[["errorkind",4]],[["iresult",6],["parseerror",8]]],[[],[["iresult",6],["parseerror",8]]],[[["usize",15]]],[[["usize",15]]],[[["usize",15]],["string",3]],[[["usize",15]],["string",3]],[[]],[[],[["error",3,["vec"]],["err",4,["error"]]]],[[]],[[],[["err",4,["error"]],["error",3,["string"]]]],[[],["err",4]],[[],["err",4]],[[],["string",3]],[[],["usize",15]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],null,null,null,null,[[]],[[]],null,null,[[]],[[]],[[]],[[]],null,null,[[["parseerror",8],["clone",8],["alt",8]]],[[],["iresult",6]],[[["parseerror",8],["permutation",8],["clone",8]]],[[],["iresult",6]],null,null,[[["char",15]]],[[["char",15]]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[["usize",15]]],[[["char",15]]],[[["char",15]]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[["usize",15]]],null,[[["u8",15]],["bool",15]],[[["u8",15]],["bool",15]],[[["u8",15]],["bool",15]],[[["u8",15]],["bool",15]],[[["u8",15]],["bool",15]],[[["u8",15]],["bool",15]],[[["u8",15]],["bool",15]],null,[[],[["parseerror",8],["iresult",6]]],[[],[["parseerror",8],["iresult",6]]],[[],[["parseerror",8],["iresult",6]]],[[],[["parseerror",8],["iresult",6]]],[[],[["char",15],["iresult",6,["char"]],["parseerror",8]]],[[["char",15]]],[[],[["parseerror",8],["iresult",6]]],[[],[["parseerror",8],["iresult",6]]],[[],[["parseerror",8],["iresult",6]]],[[],[["parseerror",8],["iresult",6]]],[[],[["parseerror",8],["iresult",6]]],[[],[["iresult",6,["i128"]],["i128",15],["parseerror",8]]],[[],[["iresult",6,["i16"]],["parseerror",8],["i16",15]]],[[],[["i32",15],["parseerror",8],["iresult",6,["i32"]]]],[[],[["i64",15],["parseerror",8],["iresult",6,["i64"]]]],[[],[["i8",15],["parseerror",8],["iresult",6,["i8"]]]],[[],[["parseerror",8],["iresult",6]]],[[],[["parseerror",8],["iresult",6]]],[[],[["parseerror",8],["iresult",6]]],[[],[["parseerror",8],["char",15],["iresult",6,["char"]]]],[[]],[[],[["parseerror",8],["iresult",6]]],[[],[["parseerror",8],["iresult",6]]],[[],[["parseerror",8],["iresult",6]]],[[]],[[]],[[],[["parseerror",8],["iresult",6]]],[[],[["parseerror",8],["iresult",6]]],[[],[["parseerror",8],["char",15],["iresult",6,["char"]]]],[[],[["parseerror",8],["u128",15],["iresult",6,["u128"]]]],[[],[["u16",15],["iresult",6,["u16"]],["parseerror",8]]],[[],[["parseerror",8],["u32",15],["iresult",6,["u32"]]]],[[],[["iresult",6,["u64"]],["u64",15],["parseerror",8]]],[[],[["iresult",6,["u8"]],["u8",15],["parseerror",8]]],[[],[["parseerror",8],["iresult",6]]],[[],[["parseerror",8],["iresult",6]]],[[],[["parseerror",8],["iresult",6]]],[[],[["parseerror",8],["iresult",6]]],[[],[["char",15],["iresult",6,["char"]],["parseerror",8]]],[[["char",15]]],[[],[["parseerror",8],["iresult",6]]],[[],[["parseerror",8],["iresult",6]]],[[],[["parseerror",8],["iresult",6]]],[[],[["parseerror",8],["iresult",6]]],[[],[["parseerror",8],["iresult",6]]],[[],[["iresult",6,["i128"]],["i128",15],["parseerror",8]]],[[],[["iresult",6,["i16"]],["parseerror",8],["i16",15]]],[[],[["i32",15],["parseerror",8],["iresult",6,["i32"]]]],[[],[["i64",15],["parseerror",8],["iresult",6,["i64"]]]],[[],[["i8",15],["parseerror",8],["iresult",6,["i8"]]]],[[],[["parseerror",8],["iresult",6]]],[[],[["parseerror",8],["iresult",6]]],[[],[["parseerror",8],["iresult",6]]],[[],[["parseerror",8],["char",15],["iresult",6,["char"]]]],[[]],[[],[["parseerror",8],["iresult",6]]],[[],[["parseerror",8],["iresult",6]]],[[],[["parseerror",8],["iresult",6]]],[[]],[[]],[[],[["parseerror",8],["iresult",6]]],[[],[["parseerror",8],["iresult",6]]],[[],[["parseerror",8],["char",15],["iresult",6,["char"]]]],[[],[["parseerror",8],["u128",15],["iresult",6,["u128"]]]],[[],[["u16",15],["iresult",6,["u16"]],["parseerror",8]]],[[],[["parseerror",8],["u32",15],["iresult",6,["u32"]]]],[[],[["iresult",6,["u64"]],["u64",15],["parseerror",8]]],[[],[["iresult",6,["u8"]],["u8",15],["parseerror",8]]],null,[[]],[[]],[[]],[[]],[[["bool",15]]],[[]],[[]],[[["clone",8],["inputlength",8]],[["parseerror",8],["clone",8],["inputlength",8],["iresult",6]]],[[],[["parseerror",8],["iresult",6]]],[[],["iresult",6]],[[]],[[]],[[]],[[]],[[],["parseriterator",3]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[],[["parseerror",8],["iresult",6]]],[[],[["usize",15],["parseerror",8],["iresult",6,["usize"]]]],[[["clone",8]]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],[[["clone",8]]],[[]],null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,[[["str",15]]],[[["str",15]]],[[["errorkind",4]]],[[["errorkind",4]]],[[["errorkind",4]]],[[["parseerror",8],["errorkind",4]],["parseerror",8]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[],["verboseerror",3]],[[],["verboseerrorkind",4]],[[],["errorkind",4]],[[]],[[]],[[]],null,[[["str",15]]],[[],["error",3]],[[],["error",3]],[[],["verboseerror",3]],[[],["verboseerror",3]],[[["deref",8],["verboseerror",3]],["string",3]],[[["str",15]]],[[],["str",15]],[[["error",3]],["bool",15]],[[["verboseerror",3]],["bool",15]],[[["verboseerrorkind",4]],["bool",15]],[[["errorkind",4]],["bool",15]],[[["errorkind",4]],["u32",15]],null,[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[]],[[]],[[]],[[]],[[["char",15]]],[[["char",15]]],[[["errorkind",4]]],[[["errorkind",4]]],[[["errorkind",4]]],[[["errorkind",4]]],[[["errorkind",4]]],[[["errorkind",4]]],[[]],null,[[]],[[]],[[]],[[]],[[["errorkind",4]],["parseerror",8]],[[["error",3]],["bool",15]],[[["verboseerror",3]],["bool",15]],[[["verboseerrorkind",4]],["bool",15]],[[["errorkind",4]],["error",3]],[[]],[[]],[[]],[[]],[[],["string",3]],[[],["string",3]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],null,null,null,null,[[["usize",15]]],[[]],[[]],[[]],[[["usize",15]]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[["usize",15]]],[[]],[[]],[[]],null,null,null,null,[[]],[[]],[[],["endianness",4]],[[]],null,[[["endianness",4]],["bool",15]],[[["formatter",3]],["result",6]],[[]],[[]],null,[[]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],[[],[["parseerror",8],["f32",15],["iresult",6,["f32"]]]],[[],[["f64",15],["parseerror",8],["iresult",6,["f64"]]]],[[],[["parseerror",8],["i128",15],["iresult",6,["i128"]]]],[[],[["parseerror",8],["iresult",6,["i16"]],["i16",15]]],[[],[["parseerror",8],["i32",15],["iresult",6,["i32"]]]],[[],[["parseerror",8],["i32",15],["iresult",6,["i32"]]]],[[],[["parseerror",8],["iresult",6,["i64"]],["i64",15]]],[[],[["iresult",6,["i8"]],["i8",15],["parseerror",8]]],[[],[["parseerror",8],["iresult",6,["u128"]],["u128",15]]],[[],[["u16",15],["iresult",6,["u16"]],["parseerror",8]]],[[],[["parseerror",8],["iresult",6,["u32"]],["u32",15]]],[[],[["parseerror",8],["iresult",6,["u32"]],["u32",15]]],[[],[["u64",15],["parseerror",8],["iresult",6,["u64"]]]],[[],[["parseerror",8],["u8",15],["iresult",6,["u8"]]]],[[],[["parseerror",8],["iresult",6,["f64"]],["f64",15]]],[[["endianness",4]]],[[["endianness",4]]],[[],[["iresult",6,["f32"]],["f32",15],["parseerror",8]]],[[],[["u32",15],["iresult",6,["u32"]],["parseerror",8]]],[[["endianness",4]]],[[["endianness",4]]],[[["endianness",4]]],[[["endianness",4]]],[[["endianness",4]]],[[],[["iresult",6,["i8"]],["i8",15],["parseerror",8]]],[[],[["parseerror",8],["f32",15],["iresult",6,["f32"]]]],[[],[["f64",15],["parseerror",8],["iresult",6,["f64"]]]],[[],[["parseerror",8],["i128",15],["iresult",6,["i128"]]]],[[],[["parseerror",8],["iresult",6,["i16"]],["i16",15]]],[[],[["parseerror",8],["i32",15],["iresult",6,["i32"]]]],[[],[["parseerror",8],["i32",15],["iresult",6,["i32"]]]],[[],[["parseerror",8],["iresult",6,["i64"]],["i64",15]]],[[],[["iresult",6,["i8"]],["i8",15],["parseerror",8]]],[[],[["parseerror",8],["iresult",6,["u128"]],["u128",15]]],[[],[["u16",15],["iresult",6,["u16"]],["parseerror",8]]],[[],[["parseerror",8],["iresult",6,["u32"]],["u32",15]]],[[],[["parseerror",8],["iresult",6,["u32"]],["u32",15]]],[[],[["u64",15],["parseerror",8],["iresult",6,["u64"]]]],[[],[["parseerror",8],["u8",15],["iresult",6,["u8"]]]],[[],[["parseerror",8],["iresult",6]]],[[],[["iresult",6],["parseerror",8]]],[[["endianness",4]]],[[["endianness",4]]],[[["endianness",4]]],[[["endianness",4]]],[[["endianness",4]]],[[],[["parseerror",8],["u8",15],["iresult",6,["u8"]]]],[[],[["parseerror",8],["f32",15],["iresult",6,["f32"]]]],[[],[["f64",15],["parseerror",8],["iresult",6,["f64"]]]],[[],[["parseerror",8],["i128",15],["iresult",6,["i128"]]]],[[],[["parseerror",8],["iresult",6,["i16"]],["i16",15]]],[[],[["parseerror",8],["i32",15],["iresult",6,["i32"]]]],[[],[["parseerror",8],["i32",15],["iresult",6,["i32"]]]],[[],[["parseerror",8],["iresult",6,["i64"]],["i64",15]]],[[],[["iresult",6,["i8"]],["i8",15],["parseerror",8]]],[[],[["parseerror",8],["iresult",6,["u128"]],["u128",15]]],[[],[["u16",15],["iresult",6,["u16"]],["parseerror",8]]],[[],[["parseerror",8],["iresult",6,["u32"]],["u32",15]]],[[],[["parseerror",8],["iresult",6,["u32"]],["u32",15]]],[[],[["u64",15],["parseerror",8],["iresult",6,["u64"]]]],[[],[["parseerror",8],["u8",15],["iresult",6,["u8"]]]],[[],[["parseerror",8],["iresult",6,["f64"]],["f64",15]]],[[["endianness",4]]],[[["endianness",4]]],[[],[["iresult",6,["f32"]],["f32",15],["parseerror",8]]],[[],[["u32",15],["iresult",6,["u32"]],["parseerror",8]]],[[["endianness",4]]],[[["endianness",4]]],[[["endianness",4]]],[[["endianness",4]]],[[["endianness",4]]],[[],[["iresult",6,["i8"]],["i8",15],["parseerror",8]]],[[],[["parseerror",8],["f32",15],["iresult",6,["f32"]]]],[[],[["f64",15],["parseerror",8],["iresult",6,["f64"]]]],[[],[["parseerror",8],["i128",15],["iresult",6,["i128"]]]],[[],[["parseerror",8],["iresult",6,["i16"]],["i16",15]]],[[],[["parseerror",8],["i32",15],["iresult",6,["i32"]]]],[[],[["parseerror",8],["i32",15],["iresult",6,["i32"]]]],[[],[["parseerror",8],["iresult",6,["i64"]],["i64",15]]],[[],[["iresult",6,["i8"]],["i8",15],["parseerror",8]]],[[],[["parseerror",8],["iresult",6,["u128"]],["u128",15]]],[[],[["u16",15],["iresult",6,["u16"]],["parseerror",8]]],[[],[["parseerror",8],["iresult",6,["u32"]],["u32",15]]],[[],[["parseerror",8],["iresult",6,["u32"]],["u32",15]]],[[],[["u64",15],["parseerror",8],["iresult",6,["u64"]]]],[[],[["parseerror",8],["u8",15],["iresult",6,["u8"]]]],[[],[["parseerror",8],["iresult",6]]],[[],[["iresult",6],["parseerror",8]]],[[["endianness",4]]],[[["endianness",4]]],[[["endianness",4]]],[[["endianness",4]]],[[["endianness",4]]],[[],[["parseerror",8],["u8",15],["iresult",6,["u8"]]]],null,[[]],[[]],[[],["iresult",6]],[[]],[[]],[[]],[[["parseerror",8],["tuple",8]]]],"p":[[4,"Err"],[4,"CompareResult"],[8,"ExtendInto"],[8,"InputIter"],[8,"InputTakeAtPosition"],[4,"Needed"],[8,"Parser"],[8,"AsBytes"],[8,"AsChar"],[3,"Map"],[3,"FlatMap"],[3,"AndThen"],[3,"And"],[3,"Or"],[3,"Into"],[8,"Compare"],[8,"ErrorConvert"],[8,"FindSubstring"],[8,"FindToken"],[8,"Finish"],[6,"IResult"],[8,"InputLength"],[8,"Offset"],[8,"ParseTo"],[8,"Slice"],[8,"InputTake"],[8,"HexDisplay"],[8,"ToUsize"],[13,"Incomplete"],[13,"Error"],[13,"Failure"],[13,"Size"],[8,"Alt"],[8,"Permutation"],[3,"ParserIterator"],[4,"ErrorKind"],[4,"VerboseErrorKind"],[8,"ContextError"],[3,"VerboseError"],[8,"ParseError"],[3,"Error"],[8,"FromExternalError"],[13,"Context"],[13,"Char"],[13,"Nom"],[4,"Endianness"],[8,"Tuple"]]},\
"nom_loc_graphemes":{"doc":"This crate provides location for <code>nom</code> with support to …","t":[3,3,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,0,11,0,11,11,11,11,11,11,11,11,11,11,3,16,3,3,8,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,10,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,3,3,3,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11],"n":["LocatedSegment","Location","as_ref","as_ref","as_str","as_str","borrow","borrow","borrow","borrow_mut","borrow_mut","clone","clone","clone_into","clone_into","cmp","cmp","column","deref","eq","eq","eq","fmt","fmt","fmt","fmt","from","from","hash","hash","into","into","line","line_column","line_span","location","ne","new","partial_cmp","partial_cmp","partial_cmp","position","segment","source","source","span","to_owned","to_owned","to_string","to_string","try_from","try_from","try_into","try_into","type_id","type_id","NewlineIndices","Output","SegmentByteIndices","Source","SourceIndex","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","clone","clone_into","cmp","contents","eq","fmt","fmt","fmt","fmt","from","from","from","full_span","get","get","hash","index","index","index","into","into","into","into_iter","into_iter","len","name","new","newline_indices","next","next","next_back","next_back","partial_cmp","seg_byte_indices","size_hint","size_hint","to_owned","to_string","try_from","try_from","try_from","try_into","try_into","try_into","type_id","type_id","type_id","Segments","Span","SpanContent","as_ref","as_ref","as_str","as_str","borrow","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","clone","clone","clone","clone_into","clone_into","clone_into","cmp","cmp","content","deref","end","eq","eq","eq","expand_lines","fmt","fmt","fmt","fmt","fmt","from","from","from","hash","hash","into","into","into","into_iter","into_iter","into_iter","len","ne","new","next","partial_cmp","partial_cmp","partial_cmp","segments","slice","source","span","start","to_owned","to_owned","to_owned","to_string","to_string","try_from","try_from","try_from","try_into","try_into","try_into","type_id","type_id","type_id"],"q":["nom_loc_graphemes","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","nom_loc_graphemes::source","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","nom_loc_graphemes::span","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""],"d":["A grapheme cluster segment with its location in the source …","The location in a source code.","","","Returns the underlying grapheme cluster segment content at …","Returns the segment (a single grapheme cluster) as a …","","","","","","","","","","","","Finds the column of this location in the source code.","","","","","","","","","","","","","","","Finds the line of this location in the source code.","Finds the line and column (respectively) of this location …","Creates a <code>Span</code> containing the whole line this location is …","Returns the location of this segment.","","Creates a new location given the source code object and …","","","","The string segment position in the source code.","Returns the single segmented pointed by this location.","Exports source code object and related items.","The source code object this location refers to.","This module provides ways of tracking ranges (spans) in …","","","","","","","","","","","Iterator over the newline indices of a source. Indices are …","Output of the indexing operation.","Iterator over the segment indices of a source. Indices are …","A source code object, such as read from a file.","An index on a source code.","","","","","","","","","","The contentss of the source.","","","","","","","","","Returns a span covering the whole source code.","Indexes the source code and returns <code>None</code> if out of bounds.","Indexes this source. It can be a single <code>usize</code> or a range …","","Indexes the source code and panics if out of bounds.","Indexes the source code and panics if out of bounds.","","","","","","","The length the source.","The (file) name of the source.","Creates a new source code object given its name and its …","Iterator over the newline indices of the source, where …","","","","","","Iterator over the segment indices of the source, where …","","","","","","","","","","","","","","Iterator over segments of a <code>Span</code>.","A span (a range) in the source code.","A type that, when displayed, shows the span contents, …","","","Gets the string this span includes as a whole.","Returns the span contents as a string.","","","","","","","","","","","","","","","","Creates a type that, when displayed, shows the span …","","The end location of this span.","","","","Expands this span in order to contain the whole lines the …","","","","","","","","","","","","","","","","","The length of this span in string segments.","","Creates a new span given the start location and length.","","","","","Creates an iterator over located grapheme cluster segments.","Slices this span to the given range. Returns <code>None</code> if the …","The source code object this span refers to.","Returns the inner span.","The start location of this span.","","","","","","","","","","","","","",""],"i":[0,0,1,2,1,2,1,2,2,1,2,1,2,1,2,1,2,1,2,1,2,2,1,1,2,2,1,2,1,2,1,2,1,1,1,2,1,1,1,2,2,1,1,0,1,0,1,2,1,2,1,2,1,2,1,2,0,3,0,0,0,4,5,6,4,5,6,4,4,4,4,4,4,4,5,6,4,5,6,4,3,4,4,3,3,4,4,5,6,5,6,4,4,4,4,5,6,5,6,4,4,5,6,4,4,4,5,6,4,5,6,4,5,6,0,0,0,7,8,7,8,7,9,8,8,7,9,8,7,9,8,7,9,8,7,8,7,8,7,7,8,8,7,7,7,9,8,8,7,9,8,7,8,7,9,8,7,9,8,7,7,7,9,7,8,8,7,7,7,8,7,7,9,8,7,8,7,9,8,7,9,8,7,9,8],"f":[null,null,[[]],[[]],[[],["str",15]],[[],["str",15]],[[]],[[]],[[]],[[]],[[]],[[],["location",3]],[[],["locatedsegment",3]],[[]],[[]],[[["location",3]],["ordering",4]],[[],["ordering",4]],[[],["usize",15]],[[],["str",15]],[[["location",3]],["bool",15]],[[],["bool",15]],[[],["bool",15]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[]],[[]],[[]],[[]],[[]],[[]],[[],["usize",15]],[[]],[[],["span",3]],[[],["location",3]],[[["location",3]],["bool",15]],[[["usize",15],["source",3]]],[[["location",3]],[["option",4,["ordering"]],["ordering",4]]],[[],[["option",4,["ordering"]],["ordering",4]]],[[],[["option",4,["ordering"]],["ordering",4]]],[[],["usize",15]],[[],["locatedsegment",3]],null,[[],["source",3]],null,[[]],[[]],[[],["string",3]],[[],["string",3]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],[[],["typeid",3]],null,null,null,null,null,[[]],[[]],[[]],[[]],[[]],[[]],[[],["source",3]],[[]],[[],["ordering",4]],[[],["str",15]],[[],["bool",15]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[]],[[]],[[]],[[],["span",3]],[[["source",3]],["option",4]],[[],["option",4]],[[]],[[["source",3]]],[[["source",3]]],[[]],[[]],[[]],[[]],[[]],[[]],[[],["usize",15]],[[],["str",15]],[[]],[[],["newlineindices",3]],[[],["option",4]],[[],["option",4]],[[],["option",4]],[[],["option",4]],[[],[["option",4,["ordering"]],["ordering",4]]],[[],["segmentbyteindices",3]],[[]],[[]],[[]],[[],["string",3]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],null,null,null,[[]],[[]],[[],["str",15]],[[],["str",15]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[],["span",3]],[[],["segments",3]],[[],["spancontent",3]],[[]],[[]],[[]],[[["span",3]],["ordering",4]],[[],["ordering",4]],[[],["spancontent",3]],[[],["str",15]],[[],["location",3]],[[["span",3]],["bool",15]],[[],["bool",15]],[[],["bool",15]],[[],["span",3]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[],["usize",15]],[[["span",3]],["bool",15]],[[["usize",15],["location",3]]],[[],["option",4]],[[["span",3]],[["option",4,["ordering"]],["ordering",4]]],[[],[["option",4,["ordering"]],["ordering",4]]],[[],[["option",4,["ordering"]],["ordering",4]]],[[],["segments",3]],[[],["option",4]],[[],["source",3]],[[],["span",3]],[[],["location",3]],[[]],[[]],[[]],[[],["string",3]],[[],["string",3]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]]],"p":[[3,"Location"],[3,"LocatedSegment"],[8,"SourceIndex"],[3,"Source"],[3,"SegmentByteIndices"],[3,"NewlineIndices"],[3,"Span"],[3,"SpanContent"],[3,"Segments"]]},\
"unicode_segmentation":{"doc":"Iterators which split strings on Grapheme Cluster, Word or …","t":[3,4,3,3,13,13,13,13,17,3,3,3,3,8,3,3,3,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,10,10,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,10,10,10,10,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,10,10,10,12],"n":["GraphemeCursor","GraphemeIncomplete","GraphemeIndices","Graphemes","InvalidOffset","NextChunk","PreContext","PrevChunk","UNICODE_VERSION","USentenceBoundIndices","USentenceBounds","UWordBoundIndices","UWordBounds","UnicodeSegmentation","UnicodeSentences","UnicodeWordIndices","UnicodeWords","as_str","as_str","as_str","as_str","borrow","borrow","borrow","borrow","borrow","borrow","borrow","borrow","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","clone","clone","clone","clone","clone","clone","clone","clone","cur_cursor","eq","fmt","fmt","fmt","from","from","from","from","from","from","from","from","from","from","from","grapheme_indices","graphemes","into","into","into","into","into","into","into","into","into","into","into","into_iter","into_iter","into_iter","into_iter","into_iter","into_iter","into_iter","into_iter","into_iter","is_boundary","ne","new","next","next","next","next","next","next","next","next","next","next_back","next_back","next_back","next_back","next_back","next_back","next_boundary","prev_boundary","provide_context","set_cursor","size_hint","size_hint","size_hint","size_hint","size_hint","size_hint","split_sentence_bound_indices","split_sentence_bounds","split_word_bound_indices","split_word_bounds","try_from","try_from","try_from","try_from","try_from","try_from","try_from","try_from","try_from","try_from","try_from","try_into","try_into","try_into","try_into","try_into","try_into","try_into","try_into","try_into","try_into","try_into","type_id","type_id","type_id","type_id","type_id","type_id","type_id","type_id","type_id","type_id","type_id","unicode_sentences","unicode_word_indices","unicode_words","0"],"q":["unicode_segmentation","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","unicode_segmentation::GraphemeIncomplete"],"d":["Cursor-based segmenter for grapheme clusters.","An error return indicating that not enough content was …","External iterator for grapheme clusters and byte offsets.","External iterator for a string’s grapheme clusters.","An error returned when the chunk given does not contain …","When requesting <code>next_boundary</code>, the cursor is moving past …","More pre-context is needed. The caller should call …","When requesting <code>prev_boundary</code>, the cursor is moving past …","The version of Unicode that this version of …","External iterator for sentence boundaries and byte offsets.","External iterator for a string’s sentence boundaries.","External iterator for word boundaries and byte offsets.","External iterator for a string’s word boundaries.","Methods for segmenting strings according to Unicode …","An iterator over the substrings of a string which, after …","An iterator over the substrings of a string which, after …","An iterator over the substrings of a string which, after …","View the underlying data (the part yet to be iterated) as …","View the underlying data (the part yet to be iterated) as …","View the underlying data (the part yet to be iterated) as …","View the underlying data (the part yet to be iterated) as …","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","The current offset of the cursor. Equal to the last value …","","","","","","","","","","","","","","","","Returns an iterator over the grapheme clusters of <code>self</code> and …","Returns an iterator over the grapheme clusters of <code>self</code>.","","","","","","","","","","","","","","","","","","","","","Determine whether the current cursor location is a …","","Create a new cursor. The string and initial offset are …","","","","","","","","","","","","","","","","Find the next boundary after the current cursor position. …","Find the previous boundary after the current cursor …","Provide additional pre-context when it is needed to decide …","Set the cursor to a new location in the same string.","","","","","","","Returns an iterator over substrings of <code>self</code>, split on …","Returns an iterator over substrings of <code>self</code> separated on …","Returns an iterator over substrings of <code>self</code>, split on …","Returns an iterator over substrings of <code>self</code> separated on …","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","Returns an iterator over substrings of <code>self</code> separated on …","Returns an iterator over the words of <code>self</code>, separated on …","Returns an iterator over the words of <code>self</code>, separated on …",""],"i":[0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,2,3,4,5,6,7,2,3,8,1,4,5,9,10,11,6,7,2,3,8,1,4,5,9,10,11,2,3,8,4,5,9,10,11,8,1,3,8,1,6,7,2,3,8,1,4,5,9,10,11,12,12,6,7,2,3,8,1,4,5,9,10,11,6,7,2,3,4,5,9,10,11,8,1,8,6,7,2,3,4,5,9,10,11,6,7,2,3,4,5,8,8,8,8,2,3,4,5,10,11,12,12,12,12,6,7,2,3,8,1,4,5,9,10,11,6,7,2,3,8,1,4,5,9,10,11,6,7,2,3,8,1,4,5,9,10,11,12,12,12,13],"f":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,[[],["str",15]],[[],["str",15]],[[],["str",15]],[[],["str",15]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[],["graphemeindices",3]],[[],["graphemes",3]],[[],["graphemecursor",3]],[[],["uwordbounds",3]],[[],["uwordboundindices",3]],[[],["unicodesentences",3]],[[],["usentencebounds",3]],[[],["usentenceboundindices",3]],[[],["usize",15]],[[["graphemeincomplete",4]],["bool",15]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[["formatter",3]],["result",6]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[["bool",15]],["graphemeindices",3]],[[["bool",15]],["graphemes",3]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[["usize",15],["str",15]],[["bool",15],["graphemeincomplete",4],["result",4,["bool","graphemeincomplete"]]]],[[["graphemeincomplete",4]],["bool",15]],[[["usize",15],["bool",15]],["graphemecursor",3]],[[],[["str",15],["option",4,["str"]]]],[[],["option",4]],[[],["option",4]],[[],[["str",15],["option",4,["str"]]]],[[],[["str",15],["option",4,["str"]]]],[[],["option",4]],[[],[["str",15],["option",4,["str"]]]],[[],[["str",15],["option",4,["str"]]]],[[],["option",4]],[[],[["str",15],["option",4,["str"]]]],[[],["option",4]],[[],["option",4]],[[],[["str",15],["option",4,["str"]]]],[[],[["str",15],["option",4,["str"]]]],[[],["option",4]],[[["usize",15],["str",15]],[["result",4,["option","graphemeincomplete"]],["graphemeincomplete",4],["option",4,["usize"]]]],[[["usize",15],["str",15]],[["result",4,["option","graphemeincomplete"]],["graphemeincomplete",4],["option",4,["usize"]]]],[[["usize",15],["str",15]]],[[["usize",15]]],[[]],[[]],[[]],[[]],[[]],[[]],[[],["usentenceboundindices",3]],[[],["usentencebounds",3]],[[],["uwordboundindices",3]],[[],["uwordbounds",3]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["result",4]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],[[],["typeid",3]],[[],["unicodesentences",3]],[[],["unicodewordindices",3]],[[],["unicodewords",3]],null],"p":[[4,"GraphemeIncomplete"],[3,"GraphemeIndices"],[3,"Graphemes"],[3,"UWordBounds"],[3,"UWordBoundIndices"],[3,"UnicodeWords"],[3,"UnicodeWordIndices"],[3,"GraphemeCursor"],[3,"UnicodeSentences"],[3,"USentenceBounds"],[3,"USentenceBoundIndices"],[8,"UnicodeSegmentation"],[13,"PreContext"]]}\
}');
if (window.initSearch) {window.initSearch(searchIndex)};