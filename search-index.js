var searchIndex = JSON.parse('{\
"memchr":{"doc":"This library provides heavily optimized routines for …","t":"DDDLLLLLLLLLLLLLLLFFFFFFAFFFFFFLLLLLLLLLLLLLLLLLLLLLNDDDDDNELLLLLLLLLLLLLLLLLLLLLLLLLLFLFLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLFLFLLLLLLLLLLLLLLLLLLLLLLL","n":["Memchr","Memchr2","Memchr3","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","from","from","from","into","into","into","into_iter","into_iter","into_iter","memchr","memchr2","memchr2_iter","memchr3","memchr3_iter","memchr_iter","memmem","memrchr","memrchr2","memrchr2_iter","memrchr3","memrchr3_iter","memrchr_iter","new","new","new","next","next","next","next_back","next_back","next_back","size_hint","size_hint","size_hint","try_from","try_from","try_from","try_into","try_into","try_into","type_id","type_id","type_id","Auto","FindIter","FindRevIter","Finder","FinderBuilder","FinderRev","None","Prefilter","as_ref","as_ref","borrow","borrow","borrow","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","build_forward","build_reverse","clone","clone","clone","clone","clone_into","clone_into","clone_into","clone_into","default","default","find","find","find_iter","find_iter","fmt","fmt","fmt","fmt","fmt","fmt","from","from","from","from","from","from","into","into","into","into","into","into","into_iter","into_iter","into_owned","into_owned","into_owned","into_owned","needle","needle","new","new","new","next","next","prefilter","rfind","rfind","rfind_iter","rfind_iter","to_owned","to_owned","to_owned","to_owned","try_from","try_from","try_from","try_from","try_from","try_from","try_into","try_into","try_into","try_into","try_into","try_into","type_id","type_id","type_id","type_id","type_id","type_id"],"q":["memchr","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","memchr::memmem","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""],"d":["An iterator for <code>memchr</code>.","An iterator for <code>memchr2</code>.","An iterator for <code>memchr3</code>.","","","","","","","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","","","","Search for the first occurrence of a byte in a slice.","Like <code>memchr</code>, but searches for either of two bytes instead …","An iterator over all occurrences of the needles in a …","Like <code>memchr</code>, but searches for any of three bytes instead …","An iterator over all occurrences of the needles in a …","An iterator over all occurrences of the needle in a …","This module provides forward and reverse substring search …","Search for the last occurrence of a byte in a slice.","Like <code>memrchr</code>, but searches for either of two bytes instead …","An iterator over all occurrences of the needles in a …","Like <code>memrchr</code>, but searches for any of three bytes instead …","An iterator over all occurrences of the needles in a …","An iterator over all occurrences of the needle in a …","Creates a new iterator that yields all positions of needle …","Creates a new iterator that yields all positions of needle …","Create a new <code>Memchr3</code> that’s initialized to zero with a …","","","","","","","","","","","","","","","","","","","Automatically detect whether a heuristic prefilter should …","An iterator over non-overlapping substring matches.","An iterator over non-overlapping substring matches in …","A single substring searcher fixed to a particular needle.","A builder for constructing non-default forward or reverse …","A single substring reverse searcher fixed to a particular …","Never used a prefilter in substring search.","Prefilter controls whether heuristics are used to …","Convert this finder into its borrowed variant.","Convert this finder into its borrowed variant.","","","","","","","","","","","","","Build a forward finder using the given needle from the …","Build a reverse finder using the given needle from the …","","","","","","","","","","","Returns the index of the first occurrence of the given …","Returns the index of the first occurrence of this needle …","Returns an iterator over all non-overlapping occurrences …","Returns an iterator over all occurrences of a substring in …","","","","","","","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","","","Convert this iterator into its owned variant, such that it …","Convert this iterator into its owned variant, such that it …","Convert this finder into its owned variant, such that it …","Convert this finder into its owned variant, such that it …","Returns the needle that this finder searches for.","Returns the needle that this finder searches for.","Create a new finder for the given needle.","Create a new reverse finder for the given needle.","Create a new finder builder with default settings.","","","Configure the prefilter setting for the finder.","Returns the index of the last occurrence of the given …","Returns the index of the last occurrence of this needle in …","Returns a reverse iterator over all non-overlapping …","Returns a reverse iterator over all occurrences of a …","","","","","","","","","","","","","","","","","","","","","",""],"i":[0,0,0,6,4,5,6,4,5,6,4,5,6,4,5,6,4,5,0,0,0,0,0,0,0,0,0,0,0,0,0,6,4,5,6,4,5,6,4,5,6,4,5,6,4,5,6,4,5,6,4,5,13,0,0,0,0,0,13,0,10,11,13,14,17,10,11,12,13,14,17,10,11,12,12,12,13,10,11,12,13,10,11,12,13,12,0,10,0,10,13,14,17,10,11,12,13,14,17,10,11,12,13,14,17,10,11,12,14,17,14,17,10,11,10,11,10,11,12,14,17,12,0,11,0,11,13,10,11,12,13,14,17,10,11,12,13,14,17,10,11,12,13,14,17,10,11,12],"f":[0,0,0,[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[1,[[3,[2]]]],[[1,1],[[3,[2]]]],[[1,1],4],[[1,1,1],[[3,[2]]]],[[1,1,1],5],[1,6],0,[1,[[3,[2]]]],[[1,1],[[3,[2]]]],[[1,1],[[7,[4]]]],[[1,1,1],[[3,[2]]]],[[1,1,1],[[7,[5]]]],[1,[[7,[6]]]],[1,6],[[1,1],4],[[1,1,1],5],[6,[[3,[2]]]],[4,[[3,[2]]]],[5,[[3,[2]]]],[6,3],[4,3],[5,3],[6],[4],[5],[[],8],[[],8],[[],8],[[],8],[[],8],[[],8],[[],9],[[],9],[[],9],0,0,0,0,0,0,0,0,[10,10],[11,11],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[12,10],[12,11],[13,13],[10,10],[11,11],[12,12],[[]],[[]],[[]],[[]],[[],13],[[],12],[[],[[3,[2]]]],[10,[[3,[2]]]],[[],14],[10,14],[[13,15],16],[[14,15],16],[[17,15],16],[[10,15],16],[[11,15],16],[[12,15],16],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[14,14],[17,17],[10,10],[11,11],[10],[11],[[],10],[[],11],[[],12],[14,[[3,[2]]]],[17,[[3,[2]]]],[[12,13],12],[[],[[3,[2]]]],[[11,18],[[3,[2]]]],[[],17],[11,17],[[]],[[]],[[]],[[]],[[],8],[[],8],[[],8],[[],8],[[],8],[[],8],[[],8],[[],8],[[],8],[[],8],[[],8],[[],8],[[],9],[[],9],[[],9],[[],9],[[],9],[[],9]],"p":[[15,"u8"],[15,"usize"],[4,"Option"],[3,"Memchr2"],[3,"Memchr3"],[3,"Memchr"],[3,"Rev"],[4,"Result"],[3,"TypeId"],[3,"Finder"],[3,"FinderRev"],[3,"FinderBuilder"],[4,"Prefilter"],[3,"FindIter"],[3,"Formatter"],[6,"Result"],[3,"FindRevIter"],[8,"AsRef"]]},\
"minimal_lexical":{"doc":"Fast, minimal float-parsing algorithm.","t":"IF","n":["Float","parse_float"],"q":["minimal_lexical",""],"d":["Generic floating-point type, to be used in generic code …","Parse float from extracted float components."],"i":[0,0],"f":[0,[1]],"p":[[15,"i32"]]},\
"nom":{"doc":"nom, eating data byte by byte","t":"DDIIIEENNIIQNIIIDIGNNIIIIDQQQQQDEINDIINIINILLLLKKALLLLLLLLLLLLLLLLLLAAALLLLAKKKLLLLAOOKKKKLLLLLLLLLLLLLLLLKLLLLLLLLLLLKKKKLLKKKKALLLLLLALKAKLLKLLLLLLKKLAKKLKKKKKKKKLLLLLLLKLLLLLLLLLLLLLLLLLLLLLLLLLLLFFAAFFFFFFIIFKFKAAFFFFFFFFFFFFFFFFFFFFFFFFFFFFAFFFFFFFAFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFLLFFFFFFLFLFLFFFFFLFFFFFFFLLLFFNNNNNNNINNNNDENNNNNINNNNNNNNNNNNNNNNNNNNINNNNNNNNNNNNNNNNNNNDENLLKLLFLLLLLLLLLLLLLLMFLLLLFFLLLLLFMLLLLLLLLLLLLKLLKLLLMLLLLFLLLLLLLLLLLLLLLLLLLLLAFFFFFFFFFFFFFFFFNENNLLLLALLLLALLLLFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFIFFKFFFF","n":["And","AndThen","AsBytes","AsChar","Compare","CompareResult","Err","Error","Error","ErrorConvert","ExtendInto","Extender","Failure","FindSubstring","FindToken","Finish","FlatMap","HexDisplay","IResult","Incomplete","Incomplete","InputIter","InputLength","InputTake","InputTakeAtPosition","Into","Item","Item","Item","Iter","IterElem","Map","Needed","Offset","Ok","Or","ParseTo","Parser","Size","Slice","ToUsize","Unknown","UnspecializedInput","and","and","and_then","and_then","as_bytes","as_char","bits","borrow","borrow","borrow","borrow","borrow","borrow","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","branch","bytes","character","clone","clone","clone_into","clone_into","combinator","compare","compare_no_case","convert","convert","eq","eq","eq","error","error_node_position","error_position","extend_into","find_substring","find_token","finish","finish","flat_map","flat_map","fmt","fmt","fmt","fmt","from","from","from","from","from","from","from","from","from","input_len","into","into","into","into","into","into","into","into","into","into","into","is_alpha","is_alphanum","is_dec_digit","is_hex_digit","is_incomplete","is_known","is_oct_digit","iter_elements","iter_indices","len","lib","map","map","map","map","map_input","map_input","multi","new","new_builder","number","offset","or","or","parse","parse","parse","parse","parse","parse","parse","parse_to","position","provide","sequence","slice","slice_index","source","split_at_position","split_at_position1","split_at_position1_complete","split_at_position_complete","take","take_split","to_hex","to_hex_from","to_owned","to_owned","to_owned","to_owned","to_owned","to_owned","to_string","to_usize","try_from","try_from","try_from","try_from","try_from","try_from","try_from","try_from","try_from","try_into","try_into","try_into","try_into","try_into","try_into","try_into","try_into","try_into","type_id","type_id","type_id","type_id","type_id","type_id","type_id","type_id","type_id","bits","bytes","complete","streaming","bool","tag","take","bool","tag","take","Alt","Permutation","alt","choice","permutation","permutation","complete","streaming","escaped","escaped_transform","is_a","is_not","tag","tag_no_case","take","take_till","take_till1","take_until","take_until1","take_while","take_while1","take_while_m_n","escaped","escaped_transform","is_a","is_not","tag","tag_no_case","take","take_till","take_till1","take_until","take_until1","take_while","take_while1","take_while_m_n","complete","is_alphabetic","is_alphanumeric","is_digit","is_hex_digit","is_newline","is_oct_digit","is_space","streaming","alpha0","alpha1","alphanumeric0","alphanumeric1","anychar","char","crlf","digit0","digit1","hex_digit0","hex_digit1","i128","i16","i32","i64","i8","line_ending","multispace0","multispace1","newline","none_of","not_line_ending","oct_digit0","oct_digit1","one_of","satisfy","space0","space1","tab","u128","u16","u32","u64","u8","alpha0","alpha1","alphanumeric0","alphanumeric1","anychar","char","crlf","digit0","digit1","hex_digit0","hex_digit1","i128","i16","i32","i64","i8","line_ending","multispace0","multispace1","newline","none_of","not_line_ending","oct_digit0","oct_digit1","one_of","satisfy","space0","space1","tab","u128","u16","u32","u64","u8","ParserIterator","all_consuming","borrow","borrow_mut","complete","cond","consumed","cut","eof","fail","finish","flat_map","from","into","into","iterator","map","map_opt","map_parser","map_res","next","not","opt","peek","recognize","rest","rest_len","success","try_from","try_into","type_id","value","verify","Alpha","AlphaNumeric","Alt","Char","Char","Complete","Context","ContextError","Count","CrLf","Digit","Eof","Error","ErrorKind","Escaped","EscapedTransform","Fail","Fix","Float","FromExternalError","HexDigit","IsA","IsNot","LengthValue","LengthValueFn","Many0","Many0Count","Many1","Many1Count","ManyMN","ManyTill","MapOpt","MapRes","MultiSpace","Nom","NonEmpty","NoneOf","Not","OctDigit","OneOf","ParseError","Permutation","RegexpCapture","RegexpCaptures","RegexpFind","RegexpMatch","RegexpMatches","Satisfy","SeparatedList","SeparatedNonEmptyList","Space","Switch","Tag","TagBits","TagClosure","TakeTill1","TakeUntil","TakeWhile1","TakeWhileMN","TooLarge","VerboseError","VerboseErrorKind","Verify","add_context","add_context","append","append","append","append_error","borrow","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","borrow_mut","clone","clone","clone","clone_into","clone_into","clone_into","code","context","convert","convert","convert","convert","convert_error","dbg_dmp","description","eq","eq","eq","eq","error_to_u32","errors","fmt","fmt","fmt","fmt","fmt","fmt","from","from","from","from","from_char","from_char","from_error_kind","from_error_kind","from_error_kind","from_external_error","from_external_error","from_external_error","hash","input","into","into","into","into","make_error","new","or","provide","provide","to_owned","to_owned","to_owned","to_string","to_string","try_from","try_from","try_from","try_from","try_into","try_into","try_into","try_into","type_id","type_id","type_id","type_id","std","count","fill","fold_many0","fold_many1","fold_many_m_n","length_count","length_data","length_value","many0","many0_count","many1","many1_count","many_m_n","many_till","separated_list0","separated_list1","Big","Endianness","Little","Native","borrow","borrow_mut","clone","clone_into","complete","eq","fmt","from","into","streaming","to_owned","try_from","try_into","type_id","be_f32","be_f64","be_i128","be_i16","be_i24","be_i32","be_i64","be_i8","be_u128","be_u16","be_u24","be_u32","be_u64","be_u8","double","f32","f64","float","hex_u32","i128","i16","i24","i32","i64","i8","le_f32","le_f64","le_i128","le_i16","le_i24","le_i32","le_i64","le_i8","le_u128","le_u16","le_u24","le_u32","le_u64","le_u8","recognize_float","recognize_float_parts","u128","u16","u24","u32","u64","u8","be_f32","be_f64","be_i128","be_i16","be_i24","be_i32","be_i64","be_i8","be_u128","be_u16","be_u24","be_u32","be_u64","be_u8","double","f32","f64","float","hex_u32","i128","i16","i24","i32","i64","i8","le_f32","le_f64","le_i128","le_i16","le_i24","le_i32","le_i64","le_i8","le_u128","le_u16","le_u24","le_u32","le_u64","le_u8","recognize_float","recognize_float_parts","u128","u16","u24","u32","u64","u8","Tuple","delimited","pair","parse","preceded","separated_pair","terminated","tuple"],"q":["nom","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","nom::bits","","","","nom::bits::complete","","","nom::bits::streaming","","","nom::branch","","","","","","nom::bytes","","nom::bytes::complete","","","","","","","","","","","","","","nom::bytes::streaming","","","","","","","","","","","","","","nom::character","","","","","","","","","nom::character::complete","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","nom::character::streaming","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","nom::combinator","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","nom::error","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","nom::lib","nom::multi","","","","","","","","","","","","","","","","nom::number","","","","","","","","","","","","","","","","","","nom::number::complete","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","nom::number::streaming","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","nom::sequence","","","","","","",""],"d":["Implementation of <code>Parser::and</code>","Implementation of <code>Parser::and_then</code>","Helper trait for types that can be viewed as a byte slice","Transforms common types to a char for basic token parsing","Abstracts comparison operations","Indicates whether a comparison was successful, an error, or","The <code>Err</code> enum indicates the parser was not successful","The parser had an error (recoverable)","Comparison failed","Equivalent From implementation to avoid orphan rules in …","Abstracts something which can extend an <code>Extend</code>. Used to …","The type that will be produced","The parser had an unrecoverable error: we got to the right …","Look for a substring in self","Look for a token in self","Helper trait to convert a parser’s result to a more …","Implementation of <code>Parser::flat_map</code>","Helper trait to show a byte slice as a hex dump","Holds the result of parsing functions","There was not enough data","We need more data to be sure","Abstracts common iteration operations on the input type","Abstract method to calculate the input length","Abstracts slicing operations","Methods to take as much input as possible until the …","Implementation of <code>Parser::into</code>","The current input type is a sequence of that <code>Item</code> type.","The current input type is a sequence of that <code>Item</code> type.","The current input type is a sequence of that <code>Item</code> type.","An iterator over the input type, producing the item and …","An iterator over the input type, producing the item","Implementation of <code>Parser::map</code>","Contains information on needed data if a parser returned …","Useful functions to calculate the offset between slices …","Comparison was successful","Implementation of <code>Parser::or</code>","Used to integrate <code>str</code>’s <code>parse()</code> method","All nom parsers implement this trait","Contains the required data size in bytes","Slicing operations using ranges.","Helper trait to convert numbers to usize.","Needs more data, but we do not know how much","Dummy trait used for default implementations (currently …","Applies a second parser after the first one, return their …","Applies a second parser after the first one, return their …","Applies a second parser over the output of the first one","Applies a second parser over the output of the first one","Casts the input type to a byte slice","makes a char from self","Bit level parsers","","","","","","","","","","","","","","","","","","","Choice combinators","Parsers recognizing bytes streams","Character specific parsers and combinators","","","","","General purpose combinators","Compares self to another value for equality","Compares self to another value for equality independently …","Transform to another error type","Automatically converts between errors if the underlying …","","","","Error management","Creates a parse error from a <code>nom::ErrorKind</code>, the position …","Creates a parse error from a <code>nom::ErrorKind</code> and the …","Accumulate the input into an accumulator","Returns the byte position of the substring if it is found","Returns true if self contains the token","converts the parser’s result to a type that is more …","","Creates a second parser from the output of the first one, …","Creates a second parser from the output of the first one, …","","","","","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Calculates the input length, as indicated by its name, and …","automatically converts the parser’s output and error …","automatically converts the parser’s output and error …","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Tests that self is an alphabetic character","Tests that self is an alphabetic character or a decimal …","Tests that self is a decimal digit","Tests that self is an hex digit","Tests if the result is Incomplete","Indicates if we know how many bytes we need","Tests that self is an octal digit","Returns an iterator over the elements","Returns an iterator over the elements and their byte …","Gets the len in bytes for self","Lib module to re-export everything needed from <code>std</code> or <code>core</code>/…","Maps a function over the result of a parser","Maps a function over the result of a parser","Maps a <code>Needed</code> to <code>Needed</code> by applying a function to a …","Applies the given function to the inner error","Maps <code>Err&lt;error::Error&lt;T&gt;&gt;</code> to <code>Err&lt;error::Error&lt;U&gt;&gt;</code> with the …","Maps <code>Err&lt;(T, ErrorKind)&gt;</code> to <code>Err&lt;(U, ErrorKind)&gt;</code> with the …","Combinators applying their child parser multiple times","Creates <code>Needed</code> instance, returns <code>Needed::Unknown</code> if the …","Create a new <code>Extend</code> of the correct type","Parsers recognizing numbers","Offset between the first byte of self and the first byte …","Applies a second parser over the input if the first one …","Applies a second parser over the input if the first one …","A parser takes in input type, and returns a <code>Result</code> …","","","","","","","Succeeds if <code>parse()</code> succeeded. The byte slice …","Finds the byte position of the element","","Combinators applying parsers in sequence","Slices self according to the range argument","Get the byte offset from the element’s position in the …","","Looks for the first element of the input type for which …","Looks for the first element of the input type for which …","Looks for the first element of the input type for which …","Looks for the first element of the input type for which …","Returns a slice of <code>count</code> bytes. panics if count &gt; length","Split the stream at the <code>count</code> byte offset. panics if count …","Converts the value of <code>self</code> to a hex dump, returning the …","Converts the value of <code>self</code> to a hex dump beginning at <code>from</code> …","","Obtaining ownership","","Obtaining ownership","Obtaining ownership","Obtaining ownership","","converts self to usize","","","","","","","","","","","","","","","","","","","","","","","","","","","","Converts a byte-level input to a bit-level input, for …","Counterpart to <code>bits</code>, <code>bytes</code> transforms its bit stream input …","Bit level parsers","Bit level parsers","Parses one specific bit as a bool.","Generates a parser taking <code>count</code> bits and comparing them to …","Generates a parser taking <code>count</code> bits","Parses one specific bit as a bool.","Generates a parser taking <code>count</code> bits and comparing them to …","Generates a parser taking <code>count</code> bits","Helper trait for the alt() combinator.","Helper trait for the permutation() combinator.","Tests a list of parsers one by one until one succeeds.","Tests each parser in the tuple and returns the result of …","Applies a list of parsers in any order.","Tries to apply all parsers in the tuple in various orders …","Parsers recognizing bytes streams, complete input version","Parsers recognizing bytes streams, streaming version","Matches a byte string with escaped characters.","Matches a byte string with escaped characters.","Returns the longest slice of the matches the pattern.","Parse till certain characters are met.","Recognizes a pattern","Recognizes a case insensitive pattern.","Returns an input slice containing the first N input …","Returns the longest input slice (if any) till a predicate …","Returns the longest (at least 1) input slice till a …","Returns the input slice up to the first occurrence of the …","Returns the non empty input slice up to the first …","Returns the longest input slice (if any) that matches the …","Returns the longest (at least 1) input slice that matches …","Returns the longest (m &lt;= len &lt;= n) input slice  that …","Matches a byte string with escaped characters.","Matches a byte string with escaped characters.","Returns the longest slice of the matches the pattern.","Parse till certain characters are met.","Recognizes a pattern.","Recognizes a case insensitive pattern.","Returns an input slice containing the first N input …","Returns the longest input slice (if any) till a predicate …","Returns the longest (at least 1) input slice till a …","Returns the input slice up to the first occurrence of the …","Returns the non empty input slice up to the first …","Returns the longest input slice (if any) that matches the …","Returns the longest (at least 1) input slice that matches …","Returns the longest (m &lt;= len &lt;= n) input slice  that …","Character specific parsers and combinators, complete input …","Tests if byte is ASCII alphabetic: A-Z, a-z","Tests if byte is ASCII alphanumeric: A-Z, a-z, 0-9","Tests if byte is ASCII digit: 0-9","Tests if byte is ASCII hex digit: 0-9, A-F, a-f","Tests if byte is ASCII newline: \\\\n","Tests if byte is ASCII octal digit: 0-7","Tests if byte is ASCII space or tab","Character specific parsers and combinators, streaming …","Recognizes zero or more lowercase and uppercase ASCII …","Recognizes one or more lowercase and uppercase ASCII …","Recognizes zero or more ASCII numerical and alphabetic …","Recognizes one or more ASCII numerical and alphabetic …","Matches one byte as a character. Note that the input type …","Recognizes one character.","Recognizes the string “\\\\r\\\\n”.","Recognizes zero or more ASCII numerical characters: 0-9","Recognizes one or more ASCII numerical characters: 0-9","Recognizes zero or more ASCII hexadecimal numerical …","Recognizes one or more ASCII hexadecimal numerical …","will parse a number in text form to a number","will parse a number in text form to a number","will parse a number in text form to a number","will parse a number in text form to a number","will parse a number in text form to a number","Recognizes an end of line (both ‘\\\\n’ and ‘\\\\r\\\\n’).","Recognizes zero or more spaces, tabs, carriage returns and …","Recognizes one or more spaces, tabs, carriage returns and …","Matches a newline character ‘\\\\n’.","Recognizes a character that is not in the provided …","Recognizes a string of any char except ‘\\\\r\\\\n’ or ‘\\\\n…","Recognizes zero or more octal characters: 0-7","Recognizes one or more octal characters: 0-7","Recognizes one of the provided characters.","Recognizes one character and checks that it satisfies a …","Recognizes zero or more spaces and tabs.","Recognizes one or more spaces and tabs.","Matches a tab character ‘\\\\t’.","will parse a number in text form to a number","will parse a number in text form to a number","will parse a number in text form to a number","will parse a number in text form to a number","will parse a number in text form to a number","Recognizes zero or more lowercase and uppercase ASCII …","Recognizes one or more lowercase and uppercase ASCII …","Recognizes zero or more ASCII numerical and alphabetic …","Recognizes one or more ASCII numerical and alphabetic …","Matches one byte as a character. Note that the input type …","Recognizes one character.","Recognizes the string “\\\\r\\\\n”.","Recognizes zero or more ASCII numerical characters: 0-9","Recognizes one or more ASCII numerical characters: 0-9","Recognizes zero or more ASCII hexadecimal numerical …","Recognizes one or more ASCII hexadecimal numerical …","will parse a number in text form to a number","will parse a number in text form to a number","will parse a number in text form to a number","will parse a number in text form to a number","will parse a number in text form to a number","Recognizes an end of line (both ‘\\\\n’ and ‘\\\\r\\\\n’).","Recognizes zero or more spaces, tabs, carriage returns and …","Recognizes one or more spaces, tabs, carriage returns and …","Matches a newline character ‘\\\\n’.","Recognizes a character that is not in the provided …","Recognizes a string of any char except ‘\\\\r\\\\n’ or ‘\\\\n…","Recognizes zero or more octal characters: 0-7","Recognizes one or more octal characters: 0-7","Recognizes one of the provided characters.","Recognizes one character and checks that it satisfies a …","Recognizes zero or more spaces and tabs.","Recognizes one or more spaces and tabs.","Matches a tab character ‘\\\\t’.","will parse a number in text form to a number","will parse a number in text form to a number","will parse a number in text form to a number","will parse a number in text form to a number","will parse a number in text form to a number","Main structure associated to the iterator function.","Succeeds if all the input has been consumed by its child …","","","Transforms Incomplete into <code>Error</code>.","Calls the parser if the condition is met.","if the child parser was successful, return the consumed …","Transforms an <code>Err::Error</code> (recoverable) to <code>Err::Failure</code> …","returns its input if it is at the end of input data","A parser which always fails.","Returns the remaining input if parsing was successful, or …","Creates a new parser from the output of the first parser, …","Returns the argument unchanged.","automatically converts the child parser’s result to …","Calls <code>U::from(self)</code>.","Creates an iterator from input data and a parser.","Maps a function on the result of a parser.","Applies a function returning an <code>Option</code> over the result of …","Applies a parser over the result of another one.","Applies a function returning a <code>Result</code> over the result of a …","","Succeeds if the child parser returns an error.","Optional parser, will return <code>None</code> on <code>Err::Error</code>.","Tries to apply its parser without consuming the input.","If the child parser was successful, return the consumed …","Return the remaining input.","Return the length of the remaining input.","a parser which always succeeds with given value without …","","","","Returns the provided value if the child parser succeeds.","Returns the result of the child parser if it satisfies a …","","","","Indicates which character was expected by the <code>char</code> function","","","Static string added by the <code>context</code> function","This trait is required by the <code>context</code> combinator to add a …","","","","","default error type, only contains the error’ location …","Indicates which parser returned an error","","","","","","This trait is required by the <code>map_res</code> combinator to …","","","","","","","","","","","","","","","Error kind given by various nom parsers","","","","","","This trait must be implemented by the error type of a nom …","","","","","","","","","","","","","","","","","","","","This error type accumulates errors and their position when …","Error context for <code>VerboseError</code>","","Creates a new error from an input position, a static …","","Combines an existing error with a new one created from the …","","","Combines an existing error with a new one created from the …","","","","","","","","","","","","","","","nom error code","Create a new error from an input position, a static string …","","","","","Transforms a <code>VerboseError</code> into a trace with input position …","Prints a message and the input if the parser fails.","Converts an ErrorKind to a text description","","","","","Converts an ErrorKind to a number","List of errors accumulated by <code>VerboseError</code>, containing the …","","","","","","","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Creates an error from an input position and an expected …","","Creates an error from the input position and an ErrorKind","","","Creates a new error from an input position, an ErrorKind …","Create a new error from an input position and an external …","Create a new error from an input position and an external …","","position of the error in the input data","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Creates an error from the input position and an ErrorKind","creates a new basic error","Combines two existing errors. This function is used to …","","","","","","","","","","","","","","","","","","","","internal std exports for no_std compatibility","Runs the embedded parser <code>count</code> times, gathering the …","Runs the embedded parser repeatedly, filling the given …","Repeats the embedded parser, calling <code>g</code> to gather the …","Repeats the embedded parser, calling <code>g</code> to gather the …","Repeats the embedded parser <code>m..=n</code> times, calling <code>g</code> to …","Gets a number from the first parser, then applies the …","Gets a number from the parser and returns a subslice of …","Gets a number from the first parser, takes a subslice of …","Repeats the embedded parser, gathering the results in a <code>Vec</code>…","Repeats the embedded parser, counting the results","Runs the embedded parser, gathering the results in a <code>Vec</code>.","Runs the embedded parser, counting the results.","Repeats the embedded parser <code>m..=n</code> times","Applies the parser <code>f</code> until the parser <code>g</code> produces a result.","Alternates between two parsers to produce a list of …","Alternates between two parsers to produce a list of …","Big endian","Configurable endianness","Little endian","Will match the host’s endianness","","","","","Parsers recognizing numbers, complete input version","","","Returns the argument unchanged.","Calls <code>U::from(self)</code>.","Parsers recognizing numbers, streaming version","","","","","Recognizes a big endian 4 bytes floating point number.","Recognizes a big endian 8 bytes floating point number.","Recognizes a big endian signed 16 bytes integer.","Recognizes a big endian signed 2 bytes integer.","Recognizes a big endian signed 3 bytes integer.","Recognizes a big endian signed 4 bytes integer.","Recognizes a big endian signed 8 bytes integer.","Recognizes a signed 1 byte integer.","Recognizes a big endian unsigned 16 bytes integer.","Recognizes a big endian unsigned 2 bytes integer.","Recognizes a big endian unsigned 3 byte integer.","Recognizes a big endian unsigned 4 bytes integer.","Recognizes a big endian unsigned 8 bytes integer.","Recognizes an unsigned 1 byte integer.","Recognizes floating point number in text format and …","Recognizes a 4 byte floating point number","Recognizes an 8 byte floating point number","Recognizes floating point number in text format and …","Recognizes a hex-encoded integer.","Recognizes a signed 16 byte integer","Recognizes a signed 2 byte integer","Recognizes a signed 3 byte integer","Recognizes a signed 4 byte integer","Recognizes a signed 8 byte integer","Recognizes a signed 1 byte integer","Recognizes a little endian 4 bytes floating point number.","Recognizes a little endian 8 bytes floating point number.","Recognizes a little endian signed 16 bytes integer.","Recognizes a little endian signed 2 bytes integer.","Recognizes a little endian signed 3 bytes integer.","Recognizes a little endian signed 4 bytes integer.","Recognizes a little endian signed 8 bytes integer.","Recognizes a signed 1 byte integer.","Recognizes a little endian unsigned 16 bytes integer.","Recognizes a little endian unsigned 2 bytes integer.","Recognizes a little endian unsigned 3 byte integer.","Recognizes a little endian unsigned 4 bytes integer.","Recognizes a little endian unsigned 8 bytes integer.","Recognizes an unsigned 1 byte integer.","Recognizes floating point number in a byte string and …","Recognizes a floating point number in text format","Recognizes an unsigned 16 byte integer","Recognizes an unsigned 2 bytes integer","Recognizes an unsigned 3 byte integer","Recognizes an unsigned 4 byte integer","Recognizes an unsigned 8 byte integer","Recognizes an unsigned 1 byte integer","Recognizes a big endian 4 bytes floating point number.","Recognizes a big endian 8 bytes floating point number.","Recognizes a big endian signed 16 bytes integer.","Recognizes a big endian signed 2 bytes integer.","Recognizes a big endian signed 3 bytes integer.","Recognizes a big endian signed 4 bytes integer.","Recognizes a big endian signed 8 bytes integer.","Recognizes a signed 1 byte integer.","Recognizes a big endian unsigned 16 bytes integer.","Recognizes a big endian unsigned 2 bytes integer.","Recognizes a big endian unsigned 3 byte integer.","Recognizes a big endian unsigned 4 bytes integer.","Recognizes a big endian unsigned 8 bytes integer.","Recognizes an unsigned 1 byte integer.","Recognizes floating point number in text format and …","Recognizes a 4 byte floating point number","Recognizes an 8 byte floating point number","Recognizes floating point number in text format and …","Recognizes a hex-encoded integer.","Recognizes a signed 16 byte integer","Recognizes a signed 2 byte integer","Recognizes a signed 3 byte integer","Recognizes a signed 4 byte integer","Recognizes a signed 8 byte integer","Recognizes a signed 1 byte integer","Recognizes a little endian 4 bytes floating point number.","Recognizes a little endian 8 bytes floating point number.","Recognizes a little endian signed 16 bytes integer.","Recognizes a little endian signed 2 bytes integer.","Recognizes a little endian signed 3 bytes integer.","Recognizes a little endian signed 4 bytes integer.","Recognizes a little endian signed 8 bytes integer.","Recognizes a signed 1 byte integer.","Recognizes a little endian unsigned 16 bytes integer.","Recognizes a little endian unsigned 2 bytes integer.","Recognizes a little endian unsigned 3 bytes integer.","Recognizes a little endian unsigned 4 bytes integer.","Recognizes a little endian unsigned 8 bytes integer.","Recognizes an unsigned 1 byte integer.","Recognizes a floating point number in text format and …","Recognizes a floating point number in text format","Recognizes an unsigned 16 byte integer","Recognizes an unsigned 2 bytes integer","Recognizes an unsigned 3 byte integer","Recognizes an unsigned 4 byte integer","Recognizes an unsigned 8 byte integer","Recognizes an unsigned 1 byte integer","Helper trait for the tuple combinator.","Matches an object from the first parser and discards it, …","Gets an object from the first parser, then gets another …","Parses the input and returns a tuple of results of each …","Matches an object from the first parser and discards it, …","Gets an object from the first parser, then matches an …","Gets an object from the first parser, then matches an …","Applies a tuple of parsers one by one and returns their …"],"i":[0,0,0,0,0,0,0,6,7,0,0,56,6,0,0,0,0,0,0,6,7,0,0,0,0,0,57,58,56,57,57,0,0,0,7,0,0,0,4,0,0,4,0,24,24,24,24,59,60,0,20,14,2,1,23,19,4,6,7,20,14,2,1,23,19,4,6,7,0,0,0,4,6,4,6,0,61,61,62,6,4,6,7,0,0,0,56,63,64,65,13,24,24,4,6,6,7,20,14,2,1,23,19,4,6,7,46,24,24,20,14,2,1,23,19,4,6,7,60,60,60,60,6,4,60,57,57,60,0,24,24,4,6,6,6,0,4,56,0,66,24,24,24,20,14,2,1,23,19,67,57,6,0,68,57,6,58,58,58,58,69,69,70,70,4,6,6,6,6,6,6,71,20,14,2,1,23,19,4,6,7,20,14,2,1,23,19,4,6,7,20,14,2,1,23,19,4,6,7,0,0,0,0,0,0,0,0,0,0,0,0,0,35,0,36,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,47,47,0,0,0,0,0,0,47,0,47,0,47,0,0,0,0,0,47,0,0,0,0,0,0,0,47,47,47,0,0,28,28,28,49,28,28,49,0,28,28,28,28,0,0,28,28,28,28,28,0,28,28,28,28,28,28,28,28,28,28,28,28,28,28,49,28,28,28,28,28,0,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,0,0,28,72,48,25,22,48,0,22,48,49,28,22,48,49,28,48,49,28,48,49,28,22,0,22,22,48,48,0,0,28,22,48,49,28,0,48,22,22,48,48,49,28,22,48,49,28,25,48,25,22,48,73,22,48,28,22,22,48,49,28,0,22,25,22,48,48,49,28,22,48,22,48,49,28,22,48,49,28,22,48,49,28,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,52,0,52,52,52,52,52,52,0,52,52,52,52,0,52,52,52,52,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,55,0,0,0,0],"f":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,[[],1],[[],1],[[],2],[[],2],[[]],[[],3],0,[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],0,0,0,[4,4],[[[6,[5]]],[[6,[5]]]],[[]],[[]],0,[[],7],[[],7],[[]],[6,6],[[4,4],8],[[[6,[9]],6],8],[[7,7],8],0,0,0,[[]],[[],[[11,[10]]]],[[],8],[[],12],[13,12],[[],14],[[],14],[[4,15],16],[[6,15],16],[[[6,[17]],15],16],[[7,15],16],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[],10],[[],[[19,[18,18]]]],[[],[[19,[18,18]]]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[],8],[[],8],[[],8],[[],8],[6,8],[4,8],[[],8],[[]],[[]],[[],10],0,[[],20],[[],20],[[4,21],4],[6,6],[[[6,[22]]],[[6,[22]]]],[6,6],0,[10,4],[[]],0,[[],10],[[],23],[[],23],[[],13],[[[20,[24,21]]],13],[[[14,[24,21]]],13],[[[2,[24,24]]],13],[[[1,[24,24]]],13],[[[23,[[24,[5,[25,[5]]]],[24,[5,[25,[5]]]]]],5],[[13,[5,[25,[5]]]]]],[[[19,[[24,[5]],18,[0,[[25,[5]],18]]]],5],[[13,[5,18,[0,[[25,[5]],18]]]]]],[[],11],[[],[[11,[10]]]],[26],0,[[]],[10,[[12,[10,4]]]],[6,[[11,[27]]]],[[],[[13,[25]]]],[28,[[13,[25]]]],[28,[[13,[25]]]],[[],[[13,[25]]]],[10],[10],[10,29],[[10,10],29],[[]],[[[6,[[22,[30]]]]],[[6,[[22,[29]]]]]],[[]],[[[6,[22]]],[[6,[[22,[[32,[31]]]]]]]],[6,6],[6,6],[[],29],[[],10],[[],12],[[],12],[[],12],[[],12],[[],12],[[],12],[[],12],[[],12],[[],12],[[],12],[[],12],[[],12],[[],12],[[],12],[[],12],[[],12],[[],12],[[],12],[[],33],[[],33],[[],33],[[],33],[[],33],[[],33],[[],33],[[],33],[[],33],[[],34],[[],34],0,0,[[],[[13,[8,25]]]],[[],21],[[],21],[[],[[13,[8,25]]]],[[],21],[[],21],0,0,[[[35,[5,[25,[5]]]]],34],[[],13],[[[36,[5,[25,[5]]]]],34],[[],13],0,0,[3,34],[3,34],[[],21],[[],21],[[],21],[[],21],[[],21],[[],21],[[],21],[[],21],[[],21],[[],21],[[],21],[[10,10],21],[3,34],[3,34],[[],21],[[],21],[[],21],[[],21],[[],21],[[],21],[[],21],[[],21],[[],21],[[],21],[[],21],[[10,10],21],0,[31,8],[31,8],[31,8],[31,8],[31,8],[31,8],[31,8],0,[[],[[13,[25]]]],[[],[[13,[25]]]],[[],[[13,[25]]]],[[],[[13,[25]]]],[[],[[13,[3,25]]]],[3,21],[[],[[13,[25]]]],[[],[[13,[25]]]],[[],[[13,[25]]]],[[],[[13,[25]]]],[[],[[13,[25]]]],[[],[[13,[37,25]]]],[[],[[13,[38,25]]]],[[],[[13,[39,25]]]],[[],[[13,[40,25]]]],[[],[[13,[41,25]]]],[[],[[13,[25]]]],[[],[[13,[25]]]],[[],[[13,[25]]]],[[],[[13,[3,25]]]],[[],21],[[],[[13,[25]]]],[[],[[13,[25]]]],[[],[[13,[25]]]],[[],21],[[],21],[[],[[13,[25]]]],[[],[[13,[25]]]],[[],[[13,[3,25]]]],[[],[[13,[42,25]]]],[[],[[13,[43,25]]]],[[],[[13,[44,25]]]],[[],[[13,[45,25]]]],[[],[[13,[31,25]]]],[[],[[13,[25]]]],[[],[[13,[25]]]],[[],[[13,[25]]]],[[],[[13,[25]]]],[[],[[13,[3,25]]]],[3,21],[[],[[13,[25]]]],[[],[[13,[25]]]],[[],[[13,[25]]]],[[],[[13,[25]]]],[[],[[13,[25]]]],[[],[[13,[37,25]]]],[[],[[13,[38,25]]]],[[],[[13,[39,25]]]],[[],[[13,[40,25]]]],[[],[[13,[41,25]]]],[[],[[13,[25]]]],[[],[[13,[25]]]],[[],[[13,[25]]]],[[],[[13,[3,25]]]],[[],21],[[],[[13,[25]]]],[[],[[13,[25]]]],[[],[[13,[25]]]],[[],21],[[],21],[[],[[13,[25]]]],[[],[[13,[25]]]],[[],[[13,[3,25]]]],[[],[[13,[42,25]]]],[[],[[13,[43,25]]]],[[],[[13,[44,25]]]],[[],[[13,[45,25]]]],[[],[[13,[31,25]]]],0,[[],34],[[]],[[]],[[],34],[8,34],[[],34],[[],34],[[[0,[46,5]]],[[13,[[0,[46,5]],[0,[46,5]],[25,[[0,[46,5]]]]]]]],[[],[[13,[25]]]],[[[47,[5]]],[[13,[5]]]],[[],34],[[]],[[],34],[[]],[[],47],[[],34],[[],34],[[],34],[[],34],[47,11],[[],34],[[],34],[[],34],[[],34],[[],[[13,[25]]]],[[],[[13,[10,25]]]],[5,21],[[],12],[[],12],[[],33],[5,34],[[],34],0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,[30],[[30,48],48],[28],[[28,22],22],[[28,48],48],[[28,25],25],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[[48,[5]]],[[48,[5]]]],[49,49],[28,28],[[]],[[]],[[]],0,[30,34],[22,22],[22,22],[48,48],[48,48],[[50,[48,[50]]],29],[30,21],[28,30],[[[22,[9]],22],8],[[[48,[9]],48],8],[[49,49],8],[[28,28],8],[28,44],0,[[[22,[17]],15],16],[[[22,[51]],15],16],[[[48,[51]],15],16],[[[48,[17]],15],16],[[49,15],16],[[28,15],16],[[]],[[]],[[]],[[]],[3],[3,48],[28],[28,22],[28,48],[28],[28,22],[28,48],[28],0,[[]],[[]],[[]],[[]],[28,25],[28,22],[[]],[26],[26],[[]],[[]],[[]],[[],29],[[],29],[[],12],[[],12],[[],12],[[],12],[[],12],[[],12],[[],12],[[],12],[[],33],[[],33],[[],33],[[],33],0,[10,34],[[],34],[[],34],[[],34],[[10,10],34],[[],34],[[],34],[[],34],[[],34],[[],34],[[],34],[[],34],[[10,10],34],[[],34],[[],34],[[],34],0,0,0,0,[[]],[[]],[52,52],[[]],0,[[52,52],8],[[52,15],16],[[]],[[]],0,[[]],[[],12],[[],12],[[],33],[[],[[13,[53,25]]]],[[],[[13,[54,25]]]],[[],[[13,[37,25]]]],[[],[[13,[38,25]]]],[[],[[13,[39,25]]]],[[],[[13,[39,25]]]],[[],[[13,[40,25]]]],[[],[[13,[41,25]]]],[[],[[13,[42,25]]]],[[],[[13,[43,25]]]],[[],[[13,[44,25]]]],[[],[[13,[44,25]]]],[[],[[13,[45,25]]]],[[],[[13,[31,25]]]],[[],[[13,[54,25]]]],[52],[52],[[],[[13,[53,25]]]],[[],[[13,[44,25]]]],[52],[52],[52],[52],[52],[[],[[13,[41,25]]]],[[],[[13,[53,25]]]],[[],[[13,[54,25]]]],[[],[[13,[37,25]]]],[[],[[13,[38,25]]]],[[],[[13,[39,25]]]],[[],[[13,[39,25]]]],[[],[[13,[40,25]]]],[[],[[13,[41,25]]]],[[],[[13,[42,25]]]],[[],[[13,[43,25]]]],[[],[[13,[44,25]]]],[[],[[13,[44,25]]]],[[],[[13,[45,25]]]],[[],[[13,[31,25]]]],[[],[[13,[25]]]],[[],[[13,[25]]]],[52],[52],[52],[52],[52],[[],[[13,[31,25]]]],[[],[[13,[53,25]]]],[[],[[13,[54,25]]]],[[],[[13,[37,25]]]],[[],[[13,[38,25]]]],[[],[[13,[39,25]]]],[[],[[13,[39,25]]]],[[],[[13,[40,25]]]],[[],[[13,[41,25]]]],[[],[[13,[42,25]]]],[[],[[13,[43,25]]]],[[],[[13,[44,25]]]],[[],[[13,[44,25]]]],[[],[[13,[45,25]]]],[[],[[13,[31,25]]]],[[],[[13,[54,25]]]],[52],[52],[[],[[13,[53,25]]]],[[],[[13,[44,25]]]],[52],[52],[52],[52],[52],[[],[[13,[41,25]]]],[[],[[13,[53,25]]]],[[],[[13,[54,25]]]],[[],[[13,[37,25]]]],[[],[[13,[38,25]]]],[[],[[13,[39,25]]]],[[],[[13,[39,25]]]],[[],[[13,[40,25]]]],[[],[[13,[41,25]]]],[[],[[13,[42,25]]]],[[],[[13,[43,25]]]],[[],[[13,[44,25]]]],[[],[[13,[44,25]]]],[[],[[13,[45,25]]]],[[],[[13,[31,25]]]],[[],[[13,[25]]]],[[],[[13,[25]]]],[52],[52],[52],[52],[52],[[],[[13,[31,25]]]],0,[[],34],[[],34],[[],13],[[],34],[[],34],[[],34],[[[55,[25]]],34]],"p":[[3,"And"],[3,"AndThen"],[15,"char"],[4,"Needed"],[8,"Clone"],[4,"Err"],[4,"CompareResult"],[15,"bool"],[8,"PartialEq"],[15,"usize"],[4,"Option"],[4,"Result"],[6,"IResult"],[3,"FlatMap"],[3,"Formatter"],[6,"Result"],[8,"Debug"],[8,"From"],[3,"Into"],[3,"Map"],[8,"Fn"],[3,"Error"],[3,"Or"],[8,"Parser"],[8,"ParseError"],[3,"Demand"],[8,"Error"],[4,"ErrorKind"],[3,"String"],[15,"str"],[15,"u8"],[3,"Vec"],[3,"TypeId"],[8,"FnMut"],[8,"Alt"],[8,"Permutation"],[15,"i128"],[15,"i16"],[15,"i32"],[15,"i64"],[15,"i8"],[15,"u128"],[15,"u16"],[15,"u32"],[15,"u64"],[8,"InputLength"],[3,"ParserIterator"],[3,"VerboseError"],[4,"VerboseErrorKind"],[8,"Deref"],[8,"Display"],[4,"Endianness"],[15,"f32"],[15,"f64"],[8,"Tuple"],[8,"ExtendInto"],[8,"InputIter"],[8,"InputTakeAtPosition"],[8,"AsBytes"],[8,"AsChar"],[8,"Compare"],[8,"ErrorConvert"],[8,"FindSubstring"],[8,"FindToken"],[8,"Finish"],[8,"Offset"],[8,"ParseTo"],[8,"Slice"],[8,"InputTake"],[8,"HexDisplay"],[8,"ToUsize"],[8,"ContextError"],[8,"FromExternalError"]]},\
"nom_grapheme_clusters":{"doc":"This crate provides location for <code>nom</code> with support to …","t":"DDCCCLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLALLLLLLALALLLLLLLLLLLLLDFFFFFFFFFFFLLFFFFFFLLLLLLLLLLLLLLLLLLLFFFFFFFFFFFFFLLLLLLLLLLLLLLLLLLLLFFFFFFLFLLLFFLLLFFLLLLFFLLLLLLFFDQDDILLLLLLLLLLLLLLLLLLLKLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLDDDDIDLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLMLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLKLLLMLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL","n":["LocatedSegment","Location","Source","Span","SpanContent","as_ref","as_ref","as_ref","as_ref","as_str","as_str","borrow","borrow","borrow","borrow_mut","borrow_mut","clone","clone","clone_into","clone_into","cmp","cmp","column","deref","eq","eq","eq","eq","fmt","fmt","fmt","fmt","from","from","hash","hash","into","into","is_alphabetic","is_alphanumeric","is_ascii_alphabetic","is_ascii_alphanumeric","is_ascii_numeric","is_digit","is_newline","is_numeric","is_single_char","is_space","is_whitespace","line","line_column","line_span","location","new","parse","partial_cmp","partial_cmp","partial_cmp","partial_cmp","position","segment","source","source","span","span","span","to_digit","to_owned","to_owned","to_string","to_string","try_from","try_from","try_into","try_into","type_id","type_id","Tag","alpha0","alpha1","alphanumeric0","alphanumeric1","any_segment","ascii_alpha0","ascii_alpha1","ascii_alphanumeric0","ascii_alphanumeric1","ascii_numeric0","ascii_numeric1","borrow","borrow_mut","char_alpha0","char_alpha1","char_alphanumeric0","char_alphanumeric1","char_numeric0","char_numeric1","clone","clone_into","cmp","compare","compare","compare","compare","compare","compare","compare","compare","compare_no_case","compare_no_case","compare_no_case","compare_no_case","compare_no_case","compare_no_case","compare_no_case","compare_no_case","crlf","digit0","digit1","digits_i128","digits_i16","digits_i32","digits_i64","digits_i8","digits_u128","digits_u16","digits_u32","digits_u64","digits_u8","eq","eq","find_token","find_token","find_token","find_token","find_token","find_token","find_token","find_token","fmt","from","hash","input_len","into","into_fn","into_iter","iter_elements","iter_indices","len","line_ending","newline","none_of","not_line_ending","numeric0","numeric1","offset","one_of","parse","partial_cmp","position","satisfy","segment","segments","slice","slice_index","space0","space1","split_at_position","split_at_position1","split_at_position1_complete","split_at_position_complete","symbol","tab","take","take_split","to_owned","try_from","try_into","type_id","whitespace0","whitespace1","NewlineIndices","Output","SegmentByteIndices","Source","SourceIndex","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","clone","clone_into","cmp","contents","eq","fmt","fmt","fmt","fmt","from","from","from","full_span","get","get","hash","index","index","index","into","into","into","into_iter","into_iter","len","name","new","newline_indices","next","next","next_back","next_back","partial_cmp","seg_byte_indices","size_hint","size_hint","to_owned","to_string","try_from","try_from","try_from","try_into","try_into","try_into","type_id","type_id","type_id","IndexedSegments","Segments","Span","SpanContent","Spanned","Symbol","as_mut","as_ref","as_ref","as_ref","as_ref","as_ref","as_str","as_str","borrow","borrow","borrow","borrow","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","clone","clone","clone","clone","clone","clone_into","clone_into","clone_into","clone_into","clone_into","cmp","cmp","cmp","compare","compare","compare","compare","compare","compare","compare","compare","compare","compare","compare","compare","compare","compare","compare","compare","compare","compare","compare","compare","compare","compare","compare","compare","compare_no_case","compare_no_case","compare_no_case","compare_no_case","compare_no_case","compare_no_case","compare_no_case","compare_no_case","compare_no_case","compare_no_case","compare_no_case","compare_no_case","compare_no_case","compare_no_case","compare_no_case","compare_no_case","compare_no_case","compare_no_case","compare_no_case","compare_no_case","compare_no_case","compare_no_case","compare_no_case","compare_no_case","content","data","deref","end","eq","eq","eq","eq","eq","eq","expand_lines","find_token","find_token","find_token","find_token","find_token","find_token","find_token","find_token","find_token","find_token","find_token","find_token","find_token","find_token","find_token","find_token","fmt","fmt","fmt","fmt","fmt","fmt","fmt","from","from","from","from","from","from_range","hash","hash","hash","indexed","indexed_segments","indexed_segments","input_len","input_len","input_len","input_len","into","into","into","into","into","into_iter","into_iter","into_iter","into_iter","iter_elements","iter_elements","iter_indices","iter_indices","len","map","new","next","next","next_back","next_back","offset","offset","partial_cmp","partial_cmp","partial_cmp","partial_cmp","partial_cmp","partial_cmp","position","position","segments","segments","size_hint","slice","slice","slice_index","slice_index","source","span","span","span","span","span","split_at_position","split_at_position","split_at_position1","split_at_position1","split_at_position1_complete","split_at_position1_complete","split_at_position_complete","split_at_position_complete","start","take","take","take_split","take_split","to_owned","to_owned","to_owned","to_owned","to_owned","to_string","to_string","try_from","try_from","try_from","try_from","try_from","try_into","try_into","try_into","try_into","try_into","try_slice","try_slice","type_id","type_id","type_id","type_id","type_id"],"q":["nom_grapheme_clusters","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","nom_grapheme_clusters::parse","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","nom_grapheme_clusters::source","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","nom_grapheme_clusters::span","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""],"d":["A grapheme cluster segment with its location in the source …","The location in a source code.","","","","","","","","Returns the underlying grapheme cluster segment content at …","Returns the segment (a single grapheme cluster) as a …","","","","","","","","","","","","Finds the column of this location in the source code. …","","","","","","","","","","Returns the argument unchanged.","Returns the argument unchanged.","","","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Tests whether this segment is alphabetic. UTF-8 alphabetic …","Tests whether this segment is alphanumeric. UTF-8 …","Tests whether this segment is ASCII alphabetic.","Tests whether this segment is ASCII alphanumeric.","Tests whether this segment is ASCII numeric.","Tests whether this segment is an ASCII digit. Digits …","Tests if this segment is only a linefeed character.","Tests whether this segment is numeric. UTF-8 numeric …","Tests whether this segment is a single character.","Tests whether this segment is a single space.","Tests whether this segment is composed only by UTF-8 …","Finds the line of this location in the source code. Line …","Finds the line and column (respectively) of this location …","Creates a <code>Span</code> containing the whole line this location is …","Returns the location of this segment.","Creates a new location given the source code object and …","Exports parse functions related to segments/grapheme …","","","","","This location’s position in the source code in terms of …","Returns the single segmented pointed by this location.","Exports source code object and related items.","The source code object this location refers to.","This module provides ways of tracking ranges (spans) in …","","","Converts this grapheme cluster to a digit of given base. …","","","","","","","","","","","A type usable as tag for a parser without having to create …","Recognizes zero or more UTF-8 alphabetic segments, …","Recognizes one or more UTF-8 alphabetic segments, possibly …","Recognizes zero or more UTF-8 alphanumeric segments, …","Recognizes one or more UTF-8 alphanumeric segments, …","Recognizes any grapheme cluster/segment.","Recognizes zero or more ASCII alphabetic segments without …","Recognizes one or more ASCII alphabetic segments without …","Recognizes zero or more ASCII alphanumeric segments …","Recognizes one or more ASCII alphanumeric segments without …","Recognizes zero or more ASCII numeric segments without …","Recognizes one or more ASCII numeric segments without …","","","Recognizes zero or more UTF-8 alphabetic segments without …","Recognizes one or more UTF-8 alphabetic segments without …","Recognizes zero or more UTF-8 alphanumeric segments …","Recognizes one or more UTF-8 alphanumeric segments without …","Recognizes zero or more UTF-8 numeric segments without …","Recognizes one or more UTF-8 numeric segments without …","","","","","","","","","","","","","","","","","","","","Recognizes the sequence <code>&quot;\\\\r\\\\n&quot;</code>.","Recognizes zero or more digits in the given base. ASCII …","Recognizes one or more digits in the given base. ASCII …","Parses a signed 128-bit number. Consumes all available …","Parses a signed 16-bit number. Consumes all available …","Parses a signed 32-bit number. Consumes all available …","Parses a signed 64-bit number. Consumes all available …","Parses a signed 8-bit number. Consumes all available …","Parses an unsigned 128-bit number. Consumes all available …","Parses an unsigned 16-bit number. Consumes all available …","Parses an unsigned 32-bit number. Consumes all available …","Parses an unsigned 64-bit number. Consumes all available …","Parses an unsigned 8-bit number. Consumes all available …","","","","","","","","","","","","Returns the argument unchanged.","","","Calls <code>U::from(self)</code>.","Converts this tag parsed into a function (also a parser).","","","","Returns the length of the tag in segments/grapheme …","Parses line ending, either a linefeed or a <code>&quot;\\\\r\\\\n&quot;</code> sequence.","Recognizes one linefeed (<code>&quot;\\\\n&quot;</code>) ASCII character.","Recognizes a grapheme clusters/segments NOT in the given …","Parses segments until a line ending (<code>&quot;\\\\n&quot;</code> or <code>&quot;\\\\r\\\\n&quot;</code>) is …","Recognizes zero or more UTF-8 numeric segments, possibly …","Recognizes one or more UTF-8 numeric segments, possibly …","","Recognizes any of the grapheme clusters/segments in the …","","","","Recognizes a character that satifies the given <code>condition</code> …","Recognizes the given grapheme cluster/segment.","Returns an iterator over the contents of segments of this …","","","Recognizes zero or more ASCII spaces.","Recognizes one or more ASCII spaces.","","","","","Executes the parser returning any data automatically …","Recognizes one tab (<code>&quot;\\\\t&quot;</code>) ASCII character.","","","","","","","Recognizes zero or more unicode whitespace graphemes.","Recognizes one or more unicode whitespace graphemes.","Iterator over the newline indices of a source. Indices are …","Output of the indexing operation.","Iterator over the segment indices of a source. Indices are …","A source code object, such as read from a file. Cloning …","An index on a source code.","","","","","","","","","","The contentss of the source.","","","","","","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns a span covering the whole source code.","Indexes the source code and returns <code>None</code> if out of bounds.","Indexes this source. It can be a single <code>usize</code> or a range …","","Indexes the source code and panics if out of bounds.","Indexes the source code and panics if out of bounds.","","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","","","The length the source.","The (file) name of the source.","Creates a new source code object given its name and its …","Iterator over the newline indices of the source, where …","","","","","","Iterator over the segment indices of the source, where …","","","","","","","","","","","","","","Iterator over segments of a <code>Span</code> which also yield postion …","Iterator over located segments of a <code>Span</code>. Created by …","A span (a range) in the source code.","A type that, when displayed, shows the span contents, …","Types that have a span associated.","A type for metadata associated with a span (“spanned data…","Helper method to make symbol mutably reference to data.","","","","","Helper method to make symbol reference to data.","Gets the string this span includes as a whole.","Returns the span contents as a string.","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","Creates a type that, when displayed, shows the span …","Metadata produced from the span.","","The end location of this span.","","","","","","","Expands this span in order to contain the whole lines the …","","","","","","","","","","","","","","","","","","","","","","","","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Creates a new span from a range of locations, where <code>end</code> is …","","","","Converts this iterator into an <code>IndexedSegments</code> iterator, …","Creates an <code>IndexedSegments</code> iterator, which yields a tuple …","Creates an <code>IndexedSegments</code> iterator, which yields a tuple …","","","","","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","","","","","","","","","The length of this span in string segments.","Helper method to convert data.","Creates a new span given the start location and length.","","","","","","","","","","","","","","","Creates an iterator over located grapheme cluster …","Creates an iterator over located grapheme cluster …","","","","","","The source code object this span refers to.","Returns the span associated with this value.","","","","The span from which metadata comes from.","","","","","","","","","The start location of this span.","","","","","","","","","","","","","","","","","","","","","","Slices this span to the given range. Returns <code>None</code> if the …","Slices the span content to the given range. Returns <code>None</code> …","","","","",""],"i":[0,0,0,0,0,1,1,3,3,1,3,1,3,3,1,3,1,3,1,3,1,3,1,3,1,3,3,3,1,1,3,3,1,3,1,3,1,3,3,3,3,3,3,3,3,3,3,3,3,1,1,1,3,1,0,1,3,3,3,1,1,0,1,0,1,3,3,1,3,1,3,1,3,1,3,1,3,0,0,0,0,0,0,0,0,0,0,0,0,17,17,0,0,0,0,0,0,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,0,0,0,0,0,0,0,0,0,0,0,0,0,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,0,0,0,0,0,0,17,0,17,17,17,0,0,17,17,17,0,0,17,17,17,17,0,0,17,17,17,17,17,17,0,0,0,30,0,0,0,11,23,24,11,23,24,11,11,11,11,11,11,11,23,24,11,23,24,11,30,11,11,30,30,11,11,23,24,23,24,11,11,11,11,23,24,23,24,11,11,23,24,11,11,11,23,24,11,23,24,11,23,24,0,0,0,0,0,0,25,10,10,19,19,25,10,19,10,26,27,19,19,25,25,10,26,27,19,25,10,26,27,19,25,10,26,27,19,25,10,19,25,10,10,10,10,10,10,10,10,10,10,10,10,19,19,19,19,19,19,19,19,19,19,19,19,10,10,10,10,10,10,10,10,10,10,10,10,19,19,19,19,19,19,19,19,19,19,19,19,10,25,19,10,10,19,19,19,25,25,10,10,10,10,10,10,10,10,10,19,19,19,19,19,19,19,19,10,10,26,27,19,19,25,10,26,27,19,25,10,10,19,25,26,10,19,10,10,19,19,10,26,27,19,25,10,26,27,19,10,19,10,19,10,25,10,26,27,26,27,10,19,10,19,19,19,25,25,10,19,10,19,26,10,19,10,19,10,31,10,19,25,25,10,19,10,19,10,19,10,19,10,10,19,10,19,10,26,27,19,25,10,19,10,26,27,19,25,10,26,27,19,25,10,19,10,26,27,19,25],"f":[0,0,0,0,0,[1,1],[1,2],[3,2],[3,3],[1,2],[3,2],[[]],[[]],[3,2],[[]],[[]],[1,1],[3,3],[[]],[[]],[[1,1],4],[[3,3],4],[1,5],[3,2],[[1,1],6],[[3,2],6],[[3,2],6],[[3,3],6],[[1,7],8],[[1,7],8],[[3,7],8],[[3,7],8],[[]],[[]],[1],[3],[[]],[[]],[3,6],[3,6],[3,6],[3,6],[3,6],[[3,9],6],[3,6],[3,6],[3,6],[3,6],[3,6],[1,5],[1],[1,10],[3,1],[[11,5],1],0,[[1,1],[[12,[4]]]],[[3,2],[[12,[4]]]],[[3,2],[[12,[4]]]],[[3,3],[[12,[4]]]],[1,5],[1,3],0,[1,11],0,[1,10],[3,10],[[3,9],[[12,[9]]]],[[]],[[]],[[],13],[[],13],[[],14],[[],14],[[],14],[[],14],[[],15],[[],15],0,[[],16],[[],16],[[],16],[[],16],[[],[[16,[3]]]],[[],16],[[],16],[[],16],[[],16],[[],16],[[],16],[[]],[[]],[[],16],[[],16],[[],16],[[],16],[[],16],[[],16],[17,17],[[]],[[17,17],4],[[17,10],18],[[17,17],18],[[17,17],18],[[17,19],18],[[17,17],18],[[17,17],18],[[17,10],18],[[17,19],18],[[17,10],18],[[17,17],18],[[17,17],18],[[17,19],18],[[17,10],18],[[17,19],18],[[17,17],18],[[17,17],18],[[],16],[9,20],[9,20],[9,20],[9,20],[9,20],[9,20],[9,20],[9,20],[9,20],[9,20],[9,20],[9,20],[17,6],[[17,17],6],[[17,3],6],[[17,2],6],[[17,2],6],[[17,3],6],[[17,3],6],[[17,2],6],[[17,3],6],[[17,2],6],[[17,7],8],[[]],[17],[17,5],[[]],[17,20],[17],[17],[17],[17,5],[[],16],[[],16],[[],20],[[],16],[[],16],[[],16],[[17,17],5],[[],20],[17,16],[[17,17],[[12,[4]]]],[17,[[12,[5]]]],[[],20],[[],20],0,[17,17],[[17,5],[[14,[5,21]]]],[[],16],[[],16],[17,[[16,[17,17]]]],[[17,22],[[16,[17,17]]]],[[17,22],[[16,[17,17]]]],[17,[[16,[17,17]]]],[[],20],[[],16],[[17,5],17],[[17,5]],[[]],[[],14],[[],14],[[],15],[[],16],[[],16],0,0,0,0,0,[[]],[[]],[[]],[[]],[[]],[[]],[11,11],[[]],[[11,11],4],[11,2],[[11,11],6],[[11,7],8],[[11,7],8],[[23,7],8],[[24,7],8],[[]],[[]],[[]],[11,10],[11,12],[11,12],[11],[11],[11],[11],[[]],[[]],[[]],[[]],[[]],[11,5],[11,2],[[],11],[11,24],[23,12],[24,12],[23,12],[24,12],[[11,11],[[12,[4]]]],[11,23],[23],[24],[[]],[[],13],[[],14],[[],14],[[],14],[[],14],[[],14],[[],14],[[],15],[[],15],[[],15],0,0,0,0,0,0,[25,25],[10,2],[10,10],[19,19],[19,2],[25,25],[10,2],[19,2],[[]],[[]],[[]],[19,2],[[]],[[]],[25],[[]],[[]],[[]],[[]],[[]],[10,10],[26,26],[27,27],[19,19],[[[25,[28]]],[[25,[28]]]],[[]],[[]],[[]],[[]],[[]],[[10,10],4],[[19,19],4],[[25,25],4],[[10,17],18],[[10,19],18],[[10,19],18],[[10,19],18],[[10,19],18],[[10,17],18],[[10,10],18],[[10,17],18],[[10,10],18],[[10,10],18],[[10,10],18],[[10,17],18],[[19,10],18],[[19,19],18],[[19,10],18],[[19,17],18],[[19,19],18],[[19,10],18],[[19,10],18],[[19,17],18],[[19,17],18],[[19,19],18],[[19,19],18],[[19,17],18],[[10,19],18],[[10,19],18],[[10,10],18],[[10,10],18],[[10,17],18],[[10,19],18],[[10,17],18],[[10,17],18],[[10,10],18],[[10,19],18],[[10,10],18],[[10,17],18],[[19,19],18],[[19,10],18],[[19,10],18],[[19,17],18],[[19,17],18],[[19,19],18],[[19,19],18],[[19,19],18],[[19,17],18],[[19,17],18],[[19,10],18],[[19,10],18],[10,19],0,[19,2],[10,1],[[10,10],6],[[19,2],6],[[19,2],6],[[19,19],6],[25,6],[[25,25],6],[10,10],[[10,2],6],[[10,2],6],[[10,2],6],[[10,3],6],[[10,3],6],[[10,3],6],[[10,2],6],[[10,3],6],[[19,2],6],[[19,2],6],[[19,3],6],[[19,3],6],[[19,2],6],[[19,3],6],[[19,3],6],[[19,2],6],[[10,7],8],[[10,7],8],[[26,7],8],[[27,7],8],[[19,7],8],[[19,7],8],[[[25,[29]],7],8],[[]],[[]],[[]],[[]],[[]],[[1,1],10],[10],[19],[25],[26,27],[10,27],[19,27],[10,5],[10,5],[19,5],[19,5],[[]],[[]],[[]],[[]],[[]],[10],[[]],[[]],[19],[10],[19],[10],[19],[10,5],[25,25],[[1,5],10],[26,12],[27,12],[26,12],[27,12],[[10,10],5],[[19,19],5],[[10,10],[[12,[4]]]],[[19,19],[[12,[4]]]],[[19,2],[[12,[4]]]],[[19,2],[[12,[4]]]],[25,[[12,[4]]]],[[25,25],[[12,[4]]]],[10,[[12,[5]]]],[19,[[12,[5]]]],[10,26],[19,26],[26],[10,10],[19,19],[[10,5],[[14,[5,21]]]],[[19,5],[[14,[5,21]]]],[10,11],[[],10],[10,10],[19,10],[25,10],0,[10,[[16,[10,10]]]],[19,[[16,[19,19]]]],[[10,22],[[16,[10,10]]]],[[19,22],[[16,[19,19]]]],[[10,22],[[16,[10,10]]]],[[19,22],[[16,[19,19]]]],[10,[[16,[10,10]]]],[19,[[16,[19,19]]]],[10,1],[[10,5],10],[[19,5],19],[[10,5]],[[19,5]],[[]],[[]],[[]],[[]],[[]],[[],13],[[],13],[[],14],[[],14],[[],14],[[],14],[[],14],[[],14],[[],14],[[],14],[[],14],[[],14],[10,[[12,[10]]]],[19,[[12,[19]]]],[[],15],[[],15],[[],15],[[],15],[[],15]],"p":[[3,"Location"],[15,"str"],[3,"LocatedSegment"],[4,"Ordering"],[15,"usize"],[15,"bool"],[3,"Formatter"],[6,"Result"],[15,"u32"],[3,"Span"],[3,"Source"],[4,"Option"],[3,"String"],[4,"Result"],[3,"TypeId"],[6,"IResult"],[3,"Tag"],[4,"CompareResult"],[3,"SpanContent"],[8,"FnMut"],[4,"Needed"],[4,"ErrorKind"],[3,"SegmentByteIndices"],[3,"NewlineIndices"],[3,"Symbol"],[3,"Segments"],[3,"IndexedSegments"],[8,"Clone"],[8,"Debug"],[8,"SourceIndex"],[8,"Spanned"]]},\
"unicode_segmentation":{"doc":"Iterators which split strings on Grapheme Cluster, Word or …","t":"DEDDNNNNRDDDDIDDDLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLKKLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLKKKKLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLKKK","n":["GraphemeCursor","GraphemeIncomplete","GraphemeIndices","Graphemes","InvalidOffset","NextChunk","PreContext","PrevChunk","UNICODE_VERSION","USentenceBoundIndices","USentenceBounds","UWordBoundIndices","UWordBounds","UnicodeSegmentation","UnicodeSentences","UnicodeWordIndices","UnicodeWords","as_str","as_str","as_str","as_str","borrow","borrow","borrow","borrow","borrow","borrow","borrow","borrow","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","clone","clone","clone","clone","clone","clone","clone","clone","cur_cursor","eq","fmt","fmt","fmt","from","from","from","from","from","from","from","from","from","from","from","grapheme_indices","graphemes","into","into","into","into","into","into","into","into","into","into","into","into_iter","into_iter","into_iter","into_iter","into_iter","into_iter","into_iter","into_iter","into_iter","is_boundary","new","next","next","next","next","next","next","next","next","next","next_back","next_back","next_back","next_back","next_back","next_back","next_boundary","prev_boundary","provide_context","set_cursor","size_hint","size_hint","size_hint","size_hint","size_hint","size_hint","split_sentence_bound_indices","split_sentence_bounds","split_word_bound_indices","split_word_bounds","try_from","try_from","try_from","try_from","try_from","try_from","try_from","try_from","try_from","try_from","try_from","try_into","try_into","try_into","try_into","try_into","try_into","try_into","try_into","try_into","try_into","try_into","type_id","type_id","type_id","type_id","type_id","type_id","type_id","type_id","type_id","type_id","type_id","unicode_sentences","unicode_word_indices","unicode_words"],"q":["unicode_segmentation","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""],"d":["Cursor-based segmenter for grapheme clusters.","An error return indicating that not enough content was …","External iterator for grapheme clusters and byte offsets.","External iterator for a string’s grapheme clusters.","An error returned when the chunk given does not contain …","When requesting <code>next_boundary</code>, the cursor is moving past …","More pre-context is needed. The caller should call …","When requesting <code>prev_boundary</code>, the cursor is moving past …","The version of Unicode that this version of …","External iterator for sentence boundaries and byte offsets.","External iterator for a string’s sentence boundaries.","External iterator for word boundaries and byte offsets.","External iterator for a string’s word boundaries.","Methods for segmenting strings according to Unicode …","An iterator over the substrings of a string which, after …","An iterator over the substrings of a string which, after …","An iterator over the substrings of a string which, after …","View the underlying data (the part yet to be iterated) as …","View the underlying data (the part yet to be iterated) as …","View the underlying data (the part yet to be iterated) as …","View the underlying data (the part yet to be iterated) as …","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","The current offset of the cursor. Equal to the last value …","","","","","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns an iterator over the grapheme clusters of <code>self</code> and …","Returns an iterator over the grapheme clusters of <code>self</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","","","","","","","","","","Determine whether the current cursor location is a …","Create a new cursor. The string and initial offset are …","","","","","","","","","","","","","","","","Find the next boundary after the current cursor position. …","Find the previous boundary after the current cursor …","Provide additional pre-context when it is needed to decide …","Set the cursor to a new location in the same string.","","","","","","","Returns an iterator over substrings of <code>self</code>, split on …","Returns an iterator over substrings of <code>self</code> separated on …","Returns an iterator over substrings of <code>self</code>, split on …","Returns an iterator over substrings of <code>self</code> separated on …","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","Returns an iterator over substrings of <code>self</code> separated on …","Returns an iterator over the words of <code>self</code>, separated on …","Returns an iterator over the words of <code>self</code>, separated on …"],"i":[0,0,0,0,11,11,11,11,0,0,0,0,0,0,0,0,0,1,3,4,5,16,18,1,3,6,11,7,8,9,4,5,16,18,1,3,6,11,7,8,9,4,5,1,3,6,7,8,9,4,5,6,11,3,6,11,16,18,1,3,6,11,7,8,9,4,5,20,20,16,18,1,3,6,11,7,8,9,4,5,16,18,1,3,7,8,9,4,5,6,6,16,18,1,3,7,8,9,4,5,16,18,1,3,4,5,6,6,6,6,1,3,8,9,4,5,20,20,20,20,16,18,1,3,6,11,7,8,9,4,5,16,18,1,3,6,11,7,8,9,4,5,16,18,1,3,6,11,7,8,9,4,5,20,20,20],"f":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,[1,2],[3,2],[4,2],[5,2],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[1,1],[3,3],[6,6],[7,7],[8,8],[9,9],[4,4],[5,5],[6,10],[[11,11],12],[[3,13],14],[[6,13],14],[[11,13],14],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[12,1],[12,3],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[6,2,10],[[15,[12,11]]]],[[10,10,12],6],[16,[[17,[2]]]],[18,17],[1,17],[3,[[17,[2]]]],[7,[[17,[2]]]],[8,[[17,[2]]]],[9,17],[4,[[17,[2]]]],[5,17],[16,[[17,[2]]]],[18,17],[1,17],[3,[[17,[2]]]],[4,[[17,[2]]]],[5,17],[[6,2,10],[[15,[[17,[10]],11]]]],[[6,2,10],[[15,[[17,[10]],11]]]],[[6,2,10]],[[6,10]],[1],[3],[8],[9],[4],[5],[[],9],[[],8],[[],5],[[],4],[[],15],[[],15],[[],15],[[],15],[[],15],[[],15],[[],15],[[],15],[[],15],[[],15],[[],15],[[],15],[[],15],[[],15],[[],15],[[],15],[[],15],[[],15],[[],15],[[],15],[[],15],[[],15],[[],19],[[],19],[[],19],[[],19],[[],19],[[],19],[[],19],[[],19],[[],19],[[],19],[[],19],[[],7],[[],18],[[],16]],"p":[[3,"GraphemeIndices"],[15,"str"],[3,"Graphemes"],[3,"UWordBounds"],[3,"UWordBoundIndices"],[3,"GraphemeCursor"],[3,"UnicodeSentences"],[3,"USentenceBounds"],[3,"USentenceBoundIndices"],[15,"usize"],[4,"GraphemeIncomplete"],[15,"bool"],[3,"Formatter"],[6,"Result"],[4,"Result"],[3,"UnicodeWords"],[4,"Option"],[3,"UnicodeWordIndices"],[3,"TypeId"],[8,"UnicodeSegmentation"]]}\
}');
if (typeof window !== 'undefined' && window.initSearch) {window.initSearch(searchIndex)};
if (typeof exports !== 'undefined') {exports.searchIndex = searchIndex};
